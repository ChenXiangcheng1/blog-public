<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM | Nemesis</title><meta name="author" content="Nemesis,chenxiangcheng1@gmail.com"><meta name="copyright" content="Nemesis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要是JVM架构、GC机制，还介绍了Java工具">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="https://blog.haruharu.top/articles/Dev/language/Java/VM/JVM/">
<meta property="og:site_name" content="Nemesis">
<meta property="og:description" content="主要是JVM架构、GC机制，还介绍了Java工具">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_13_14_00.png">
<meta property="article:published_time" content="2023-07-12T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-18T04:14:05.537Z">
<meta property="article:author" content="Nemesis">
<meta property="article:tag" content="博客,ACM,技术,开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_13_14_00.png"><link rel="shortcut icon" href="/img/favicon48.ico"><link rel="canonical" href="https://blog.haruharu.top/articles/Dev/language/Java/VM/JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Nemesis","link":"链接: ","source":"来源: Nemesis","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-18 12:14:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 23
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_13_14_00.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Nemesis"><span class="site-name">Nemesis</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-12T16:00:00.000Z" title="发表于 2023-07-13 00:00:00">2023-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-18T04:14:05.537Z" title="更新于 2024-03-18 12:14:05">2024-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/VM/">VM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>JVM主要考点</h1>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/">Java Language and Virtual Machine Specifications (Java 语言和虚拟机规范)</a></p>
<p>JVM：</p>
<ul>
<li>
<p>HotSpot：由OpenJDK维护</p>
</li>
<li>
<p>OpenJ9：<a target="_blank" rel="noopener" href="https://eclipse.dev/openj9/">官网</a>	|	<a target="_blank" rel="noopener" href="https://github.com/eclipse-openj9/openj9">github</a></p>
</li>
<li>
<p>Azul Zing(收费)</p>
</li>
</ul>
<h2 id="1-HotSpot-VM-架构">1 HotSpot VM 架构</h2>
<p>JVM是内存中的虚拟机主要由 Class Loader 类加载器、Runtime Data Area 运行时数据区、Execution Engine 执行引擎、Native Interface 本地接口四部分构成，主要通过 Class Loader 将符合格式要求的class文件加载到内存，并通过 Execution Engine 解析里面的字节码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_13_14_00.png" alt="image-20230513140058796"></p>
<ul>
<li>
<p><strong>Class Loader</strong>：类加载器，将符合格式要求的 class 字节码文件加载到内存</p>
</li>
<li>
<p><strong>Execution Engine</strong>：执行引擎，字节码解释成机械指令码</p>
</li>
<li>
<p><strong>Native Interface</strong>：本地方法接口，融合不同开发语言的原生库为Java所用 (例把C/C++编译成了DLL)，通过 native 本地方法调用，例如 Class.forname 就调用了原生方法 forName0</p>
</li>
<li>
<p><strong>Runtime Data Area</strong>：运行时数据区，Java 内存空间结构模型</p>
</li>
</ul>
<h3 id="类从编译到执行的过程">类从编译到执行的过程</h3>
<ol>
<li>编译器将 ClassName.java 源文件<strong>编译</strong>为 ClassName.class 字节码文件</li>
<li><strong>ClassLoader</strong> 将字节码转换为 <strong>JVM 中的 Class&lt;ClassName&gt;对象</strong> (类的装载过程：加载、链接、初始化) 类文件常量池</li>
<li>JVM 利用 Class&lt;ClassName&gt; 对象<strong>实例化</strong>为 ClassName 对象</li>
</ol>
<p>执行过程：编译时、字节码加载时、运行时 (=动态)</p>
<h3 id="Native-原生方法">Native 原生方法</h3>
<p>可以通过 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/tree/master/src/java.base/share/native/libjava">github openJDK 源码</a> 查看</p>
<h2 id="反射">反射</h2>
<p>看 <a href="../Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.md">Java反射机制</a></p>
<h2 id="执行引擎">执行引擎</h2>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_194939.png" alt="image-20231027194938982" style="zoom: 45%;" />
<p>JIT (Just-In-Time)，将程序源代码(热点代码)在<strong>运行时编译</strong>成机械码并缓存，提高了运行效率，但启动速度更慢</p>
<p>AOT (Ahead-Of-Time)，将程序源代码<strong>提前编译</strong>成可执行文件，提高了启动速度和运行效率，但编译时间更长</p>
<h2 id="2-ClassLoader">2 ClassLoader</h2>
<p>ClassLoader 是 Java 的核心组件，它主要工作在 Class 装载的加载阶段，负责从系统外部获得 <strong>Class 二进制数据流</strong>，所有的 Class 都是由ClassLoader 进行加载的，然后交给 Java 虚拟机进行连接、初始化等操作。</p>
<h3 id="层次结构">层次结构</h3>
<p>Java17 的 ClassLoader 种类：</p>
<p><strong>Bootstrap ClassLoader</strong> 引导类加载器：是 JVM 的一部分，负责加载核心库 (java.*)<br>
<strong>Platform ClassLoader</strong> 平台类加载器：是 JVM 的一部分， 负责加载扩展库 (Java SE platform APIs)<br>
<strong>Application ClassLoader</strong> 应用类加载器：JVM内置，负责加载应用程序的类 (默认类加载器)。<br>
<strong>自定义 ClassLoader</strong>：能实现特定的类加载需求。</p>
<h4 id="自定义-ClassLoader-可使用字节码增强技术">自定义 ClassLoader 可使用字节码增强技术</h4>
<p>自定义 ClassLoader：</p>
<ol>
<li>
<p>继承 ClassLoader 抽象类</p>
</li>
<li>
<p>重写 <code>findClass()</code> 方法返回 Class&lt;ClassName&gt; 对象</p>
</li>
<li>
<p>自定义找到 .class 字节码文件读出，按字节流加载</p>
</li>
<li>
<p>调用 <code>defineClass()</code> 方法解析字节数组来生成 Class&lt;ClassName&gt; 实例，并加载到 JVM。返回 Class&lt;ClassName&gt; 对象</p>
</li>
</ol>
<p>调用：</p>
<ol>
<li>new 自定义 ClassLoader</li>
<li>调用 <code>loadClass(“ClassName”)</code> 方法，<code>loadClass()</code> 方法会掉用自定义 <code>findClass()</code> 方法，返回 Class&lt;ClassName&gt; 对象</li>
</ol>
<p>应用场景：</p>
<p>​	通过对字节数组操作（<strong>字节码增强技术</strong>ASM）可以<strong>访问远程类</strong>、对<strong>敏感信息加密</strong>。<br>
​	实现AOP、Cglib</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class <span class="title function_">findClass</span><span class="params">(String name)</span> &#123;  <span class="comment">// 用于寻找类文件</span></span><br><span class="line">        <span class="type">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="string">&quot;com.interview.javabasic.reflect.Wali&quot;</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">        <span class="comment">// return defineClass(name, b, 0, b.length);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) &#123;  <span class="comment">//用于加载类文件</span></span><br><span class="line">        <span class="comment">// name = name.split(&quot;\\.&quot;)[name.split(&quot;\\.&quot;).length];</span></span><br><span class="line">        name = path + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>)</span><br><span class="line">                    in.close();</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="literal">null</span>)</span><br><span class="line">                    out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> out != <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;F:\\dev-projects\\IdeaProjects\\javabasic\\src\\com\\interview\\javabasic\\reflect\\&quot;</span>, <span class="string">&quot;myClassLoader&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> m.loadClass(<span class="string">&quot;Wali&quot;</span>);</span><br><span class="line">        <span class="comment">// Class c = m.loadClass(&quot;com.interview.javabasic.reflect.Wali&quot;);</span></span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        System.out.println(c.getClassLoader().getParent());</span><br><span class="line">        System.out.println(c.getClassLoader().getParent().getParent());</span><br><span class="line">        System.out.println(c.getClassLoader().getParent().getParent().getParent());</span><br><span class="line">&#125;	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.interview.javabasic.reflect.MyClassLoader@30dae81</span><br><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@e9e54c2</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@7106e68e</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<h3 id="双亲委派机制">双亲委派机制</h3>
<p><strong>ClassLoader 在加载类时会委派给父类加载器尝试加载</strong>。</p>
<p>双亲委派模型的作用：逐层查找，避免多份同样的字节码的加载</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_16_19_42.png" alt="image-20230516194228426" style="zoom: 50%;" />
<h3 id="类的装载过程">类的装载过程</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/feedfor/jls-chinese/blob/master/12-%E6%89%A7%E8%A1%8C.md">Java 语言规范(中文翻译)#执行</a></p>
<p>我们约定用装载表示 Class 对象的生成过程，而加载是其中的一个部分</p>
<ol>
<li>
<p><strong>加载</strong> <code>loadClass()</code>：通过 ClassLoader 的 <code>loadClass()</code> 方法加载 .class 文件字节码到 JVM 内存中，并将静态数据转化为运行时方法区中的类结构数据，在运行时<strong>数据区</strong>中生成代表这个类的 <strong>Java.lang.Class 对象</strong>作为<strong>方法区 (MetaSpace元空间)<strong>这个</strong>类结构数据</strong>的访问入口</p>
</li>
<li>
<p><strong>链接</strong> <code>resolveClass()</code>：<br>
<strong>校验</strong>：检查加载的 .class 文件的正确性和安全性<br>
<strong>准备</strong>：为 <strong>static 类变量 <strong>(static 字段、static 常量) <strong>分配存储空间</strong>并设置类变量初始值，类变量随类型信息存放在方法区(MetaSpace 元空间)中，static 变量生命周期很长使用不当容易造成内存泄漏<br>
<strong>解析符号引用</strong>(可选)：JVM 将常量池内的</strong>符号引用转换为直接引用</strong> (符号引用是类的<strong>全限定名</strong>、<strong>方法名</strong>等，需要先解析再定位到目标)</p>
</li>
<li>
<p><strong>初始化</strong>：执行父类初始化、类变量初始化和执行静态代码块</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLoader.java</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);  <span class="comment">// 调用自定义ClassLoader的findClass()方法</span></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve)</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示装载和隐式装载">显示装载和隐式装载</h4>
<p>隐式装载：new (<strong>在GC堆中</strong>分配了内存空间，<strong>创建实例</strong>)</p>
<p>显式装载：ClassLoader.loadClass (<strong>没有初始化</strong>)、Class.forName (<strong>初始化完成</strong>)等</p>
<h5 id="loadClass-和-forName-的区别">loadClass 和 forName 的区别</h5>
<ul>
<li>
<p><code>Class.forName()</code> 得到的 class，是已经初始化完成的</p>
</li>
<li>
<p><code>Classloder.loadClass()</code> 得到的 class，是还没有初始化的</p>
</li>
</ul>
<p>例子：</p>
<ul>
<li>
<p>Mysql5 驱动 com.mysql.jdbc.Driver，因为Driver中有静态代码段需要执行，所以需要使用 Class.forName 加载</p>
</li>
<li>
<p>在 Spring IOC 中使用 lazyload 延迟加载技术，即在资源加载器读入 bean 的配置文件时，如果是以 Classpath 的方式就通过 Classloder.loadClass 加载。</p>
</li>
</ul>
<h2 id="3-Java内存区域划分">3 Java内存区域划分</h2>
<p>C语言内存结构模型：数据段(=堆+栈+静态数据区) + 代码段</p>
<p>JDK8 内存结构模型：分为<strong>线程独占部分</strong>和<strong>线程共享部分</strong></p>
<p>每一个进程对应一个 JVM 实例，对应一个堆</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_14_12.png" alt="image-20230517141200811" style="zoom: 40%;" />
<h3 id="线程私有部分-本地内存">线程私有部分 (本地内存)</h3>
<p>属于线程私有数据区域，对其他线程不可见，不存在线程安全问题</p>
<p><strong>PC</strong></p>
<ul>
<li>
<p>是逻辑计数器，存字节码指令的内存地址</p>
</li>
<li>
<p>对 Java 方法计数，如果是 Native 方法则计数器值为 Undefined</p>
</li>
</ul>
<h4 id="虚拟机栈">虚拟机栈</h4>
<p>Java方法执行时的内存模型，包含多个栈帧，存储了当前方法的所有本地变量信息</p>
<p><strong>栈帧</strong></p>
<ul>
<li>
<p><strong>栈帧 = 局部变量表 + 操作数栈 + 动态链接 + 返回地址</strong><br>
局部变量表：包含方法执丸行过程中的所有变量，为操作数栈提供数据支撑<br>
操作数栈：入栈、出栈、复制、交换所产生的消费变量</p>
</li>
<li>
<p><strong>方法执行结束自动释放栈帧，不需要 GC 回收</strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_14_19.png" alt="image-20230517141924805" style="zoom: 40%;" />
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_14_45.png" alt="image-20230517144531900" style="zoom:40%;" />
<p><strong>本地方法栈</strong></p>
<p>与虚拟机栈相似，存储本地方法的信息</p>
<h5 id="SOF-栈溢出异常、OOM-内存溢出异常">SOF 栈溢出异常、OOM 内存溢出异常</h5>
<ul>
<li>
<p>递归深度太深，会引发 java.lang.StackOverflowError 异常，栈溢出</p>
</li>
<li>
<p>虚拟机栈过多 (线程过多) 会引发 java.lang.OutOfMemoryError 异常，内存不够</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">while</span>(<span class="literal">true</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="literal">true</span>) &#123;&#125;                </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">&#125;	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程共享部分-主内存">线程共享部分 (主内存)</h3>
<p>属于数据共享的区域，多线程并发操作时会引发线程安全问题</p>
<p>主内存共享的方式是：线程各拷贝一份数据到工作内存(线程独占)，操作完成后刷新回主内存</p>
<h4 id="元空间-使用本地内存">元空间 使用本地内存</h4>
<p><strong>方法区</strong>是 JMM 规范中定义的一种内存区域，<strong>存储类的元信息</strong><br>
具体实现有：</p>
<ul>
<li>永久代(PermGen)(Java[7-)，使用 JVM 内存固定分配 <code>-XX:MaxPermSize</code></li>
<li><strong>元空间(MetaSpace)(Java[8+)，使用操作系统的本地内存进行动态分配</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_10_17_18.png" alt="image-20230910171807627" style="zoom:50%;" />
<p>MetaSpace 相比 PermGen 的优势</p>
<ul>
<li>
<p>字符串常量池存在永久代(JVM)中，容易出现性能问题和内存溢出</p>
</li>
<li>
<p>类和方法的信息大小难易确定，给永久代的大小指定带来困难 (元空间动态分配，不用指定初始化大小)</p>
</li>
<li>
<p>永久代会为 GC 带来不必要的复杂性，需要特别处理回收效率低 (元空间使用本地内存，不会因空间不足而触发 Full GC)</p>
</li>
<li>
<p>元空间方便 HotSpot VM 与其他 VM 如 rockit 的集成</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>PermGen的缺点</th>
<th>MetaSpace的优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串常量池存在永久代(JVM)中，容易出现性能问题和内存溢出</td>
<td></td>
</tr>
<tr>
<td>类和方法的信息大小难易确定，给永久代的大小指定带来困难</td>
<td>元空间动态分配，不用指定初始化大小</td>
</tr>
<tr>
<td>永久代会为 GC 带来不必要的复杂性，需要特别处理回收效率低</td>
<td>元空间使用本地内存，不会因空间不足而触发 Full GC</td>
</tr>
<tr>
<td></td>
<td>元空间方便 HotSpot VM 与其他 VM 如 rockit 的集成</td>
</tr>
</tbody>
</table>
<p>类文件常量池：</p>
<p>字符串常量池：</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_11_20_19.png" alt="image-20230911201951346" style="zoom: 65%;" />
<p>运行时常量池：</p>
<p>浮点数常量：3.14<br>
布尔常量：true、false<br>
整型常量：范围为[-128, 128)<br>
类和接口的全限定名<br>
符号引用：类或接口的名称、方法的名称和描述符、字段的名称和描述符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">128</span>;</span><br><span class="line">Integer b=<span class="number">128</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">Integer a=-<span class="number">128</span>;</span><br><span class="line">Integer b=<span class="number">128</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>基本数据的包装类型存储在 GC 堆</p>
<h4 id="GC堆">GC堆</h4>
<ul>
<li><strong>常量池</strong> (=静态字段 + 符号引用(=类全限定名+方法名) )</li>
<li><strong>实例对象的分配区域</strong> (数组+类对象)</li>
</ul>
<p>堆是 GC 管理的主要区域，因此也被称为 GC 堆</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_15_46.png" alt="image-20230517154645449" style="zoom: 67%;" />
<h5 id="GC-堆内存区域的划分-重点">GC 堆内存区域的划分(重点)</h5>
<ul>
<li><strong>年轻代</strong>：是用于存放新创建的对象的区域
<ul>
<li><strong>Eden 区8</strong>：</li>
<li><strong>两个 Survivor 区</strong>：分为 <strong>From 区1</strong>、<strong>To 区1</strong></li>
</ul>
</li>
<li><strong>老年代20</strong>：是用于存放长时间存活的对象的区域。在经过多次 Minor GC 后，仍然存活的对象会被晋升到老年代。</li>
</ul>
<table>
    <tr>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_18_34.png" alt="image-20230519183404821" style="zoom: 50%;" /></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_18_35.png" alt="image-20230519183415831" style="zoom: 40%;" /><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_19_08.png" alt="image-20230519190841976" style="zoom:80%;" /></center></td>
    </tr>
    <tr>
    	<td><center/>JDK[7-</center></td>
    	<td><center/>JDK[8+</center></td>
    </tr>
</table>
<h3 id="常考题解析">常考题解析</h3>
<h4 id="三大性能调优参数">三大性能调优参数</h4>
<p><code>java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar</code></p>
<p>-Xss：规定了每个线程虚拟机栈（堆栈）的大小，常 256k<br>
-Xms：堆的初始值<br>
-Xmx：堆能达到的最大值<br>
通常 Xms 和 Xmx 设置成一样的，避免内存抖动</p>
<h4 id="堆和栈的区别">堆和栈的区别</h4>
<p>内存分配策略：</p>
<p>静态存储：<strong>编译时</strong>确定每个数据目标在运行时的存储空间需求，要求程序代码中没有可变数据结构，没有嵌套和递归代码<br>
栈式存储：数据区需求在编译时未知，<strong>运行时</strong>进入 module 模块入口前需要能确定运行时的存储空间需求，动态分配<br>
堆式存储：编译时或运行时模块入口都无法确定，<strong>动态分配</strong></p>
<p><strong>联系：</strong></p>
<p>堆和栈都是 JMM 规范中定义的概念。</p>
<p><strong>GC堆 = 常量池 + 存储实例对象</strong><br>
<strong>栈 = 存储地址</strong>，指向对应的堆中的实例对象</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_17_12.png" alt="image-20230517171251767" style="zoom: 60%;" />
<h5 id="区别-重点-：">区别 (重点)：</h5>
<table>
<thead>
<tr>
<th></th>
<th>栈</th>
<th>堆</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程</td>
<td>线程私有</td>
<td>线程共享</td>
</tr>
<tr>
<td>管理方式</td>
<td>自动释放</td>
<td>需要 GC 垃圾回收</td>
</tr>
<tr>
<td>空间大小</td>
<td>栈比堆小，使用 JVM 内存</td>
<td>使用 OS 内存</td>
</tr>
<tr>
<td>碎片相关</td>
<td>栈产生的碎片远远小于堆，因为堆空间活动多</td>
<td></td>
</tr>
<tr>
<td>分配方式</td>
<td>支持静态分配和动态分配</td>
<td>仅支持动态分配</td>
</tr>
<tr>
<td>效率</td>
<td>栈的使用效率比堆高</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="栈、堆、元空间-内存角度">栈、堆、元空间(内存角度)</h5>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_17_17_06.png" alt="image-20230517170601579" style="zoom:60%;" />
<h2 id="4-GC-机制">4 GC 机制</h2>
<h3 id="GC堆中标记强引用垃圾">GC堆中标记强引用垃圾</h3>
<p>无论引用计数算法还是可达性分析算法都是基于强引用而言的</p>
<p>目前大多数 JVM 采用可达性分析算法</p>
<h4 id="引用计数法">引用计数法</h4>
<p>通过判断对象的引用数量来决定对象是否可以被回收</p>
<ul>
<li>堆中每个对象实例都有一个引用计数器，被引用则+1，完成引用(生命周期结束、新值)则-1</li>
<li>任何引用计数为0的对象实例可以被当作垃圾收集</li>
</ul>
<p>优点：执行效率高，程序执行受影响较小，几乎不打断程序的执行，适合实时环境<br>
<strong>缺点：<strong>无法检测出</strong>循环引用，会导致内存泄露</strong></p>
<h4 id="可达性分析">可达性分析</h4>
<p>Reachability analysis，通过判断对象的引用链是否可达来决定对象是否可以被回收</p>
<p>可以作为 GC Root 的对象：</p>
<ul>
<li>虚拟机<strong>栈中的引用对象</strong>（栈帧中的本地变量表，局部变量）</li>
<li>方法区中的常量引用的对象（常量）</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中 JNI (Native方法) 的引用对象</li>
<li><strong>活跃线程</strong>的引用对象</li>
<li><strong>不包括 GC 堆里</strong>面的对象指针</li>
</ul>
<p>RootSet = 全局根+线程根</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_10_01_48.png" alt="image-20230910014801040" style="zoom: 67%;" />
<h4 id="方法区标记垃圾">方法区标记垃圾</h4>
<p>垃圾：废弃常量(可达性分析)、无用的类(条件：该类所有实例已被回收、对应的ClassLoader已被回收、无Class引用)</p>
<h3 id="回收垃圾的4种算法">回收垃圾的4种算法</h3>
<p>标记-清除算法、标记-整理算法、复制算法、分代搜集算法(主流)</p>
<table>
    <tr>
    	<td width=50%>
        	<p>
<center><strong>标记-清除算法</strong></center><br/>
Tracing 跟踪 Collector 收集器<br/>
&emsp;&emsp;1. Mark 标记阶段：使用可达性分析算法，从 GCRoot 根集合进行扫描，对存活的对象进行标记<br/>
&emsp;&emsp;2. Sweep 清除阶段：对堆内存从头到尾进行线性遍历，回收不可达对象的内存<br/>
&emsp;&emsp;优点：不需要对对象进行移动，仅对不存活的对象处理。在存活对象比较多时高效<br/>
&emsp;&emsp;缺点：需要使用一个空闲列表记录有所的空闲区域与大小，可用内存碎片化<br/>
<strong>标记阶段完成后，直接清理</strong><br/><br/>
            </p>
        </td>
        <td  width=50>
        	<p>
<center><strong>标记-整理算法</strong></center><br/>
Compacting 压缩 Collector 收集器<br/>
&emsp;&emsp;1. Mark 标记阶段：使用可达性分析算法，从 GCRoot 根集合进行扫描，对存活的对象进行标记<br/>
&emsp;&emsp;2. Sweep 清除阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收<br/>
&emsp;&emsp;优点：新对象的分配只需要通过指针碰撞就可以完成，空闲区域始终可知也不会再有碎片化问题<br/>
&emsp;&emsp;缺点：GC 暂停的时间会增长，因为需要将对象拷贝到新的地方还需要更新它们的引用地址<br/>
场景：用于老年代 (对象存活率高的场景)<br/>
<strong>标记阶段完成后，移动后清理</strong><br/>    
            </p>
        </td>
    </tr>
    <tr>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_10_01_53.png" alt="image-20230910015302181" style="zoom:100%;" /></center></td>
       	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_10_02_00.png" alt="image-20230910020038800" style="zoom:80%;" /></center></td>
    </tr>
</table>
<table>
    <tr>
    	<p>
<strong>标记-复制算法</strong><br/>
&emsp;&emsp;1. 标记存活对象<br/>
&emsp;&emsp;2. 复制 Eden 区存活对象<br/>
&emsp;&emsp;3. 清空 Eden 区<br/>
&emsp;&emsp;4. 交换 Survivor 区<br/>
&emsp;&emsp;5. 年龄计算<br/>
<br/>
复制算法 Copying，内存分为对象面和空闲面<br/>
&emsp;&emsp;1. 对象在对象面上创建<br/>
&emsp;&emsp;2. 将存活的对象从对象面复制到空闲面<br/>
&emsp;&emsp;3. 回收对象面的不可达对象内存<br/>
优点：两个内存区域交替使用，<strong>解决了可用内存碎片化问题</strong>(顺序分配内存只需移动堆顶指针)，多区域不用统一回收可以减少STW<br/>
缺点：浪费内存<br/>
场景：用于年轻代(对象存活率低的场景)<br/>        
        </p>
    </tr>
    <tr>
    	<td width=33%><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_18_48.png" alt="image-20230519184847441" style="zoom: 67%;" /></center></td>
    	<td width=33%><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_18_49.png" alt="image-20230519184901206" style="zoom: 50%;" /></center></td>
        <td width=33%><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_18_22.png" alt="image-20230519182219841" style="zoom: 50%;" /></td>
    </tr>
</table>
<h3 id="常见的垃圾收集器">常见的垃圾收集器</h3>
<p><a target="_blank" rel="noopener" href="https://chriswhocodes.com/gc-explorer.html">指定JVM指定版本的垃圾收集器的可用性</a></p>
<p>指标：低延迟(STW时间尽可能短)、高吞吐(回收内存尽可能快)</p>
<p>不同的垃圾收集器，表示不同的回收策略。</p>
<p>目前现状：GC 还在飞速发展… (JDK11推出 Epsilon GC(用于测试) 和 ZGC、JDK15推出Shenandoah、JDK21推出分代ZGC)</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_20_19_53.png" alt="image-20230520195351495" style="zoom: 50%;" />
<table>
<thead>
<tr>
<th>JDK</th>
<th>年轻代的垃圾收集器</th>
<th>启动参数</th>
<th>回收垃圾的算法</th>
<th>线程</th>
<th>应用线程与GC线程</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Serial GC</td>
<td><code>-XX:+UseSerialGC</code></td>
<td>标记-复制算法</td>
<td>单线程</td>
<td></td>
<td>适用于小型或客户端应用，目标是最大化响应时间</td>
</tr>
<tr>
<td></td>
<td>Serial Old</td>
<td><code>-XX:+UseSerialOldGC</code></td>
<td>标记-整理算法</td>
<td>单线程</td>
<td></td>
<td>适用于小型或客户端应用。</td>
</tr>
<tr>
<td></td>
<td>ParNew GC</td>
<td><code>-XX:+UseParNewGC</code></td>
<td>标记-复制算法</td>
<td>多线程</td>
<td></td>
<td>是 Serial GC 的多线程版本，适用于多核服务器，目标是提高吞吐量</td>
</tr>
<tr>
<td>(5默认)</td>
<td>Parallel Scavenge</td>
<td><code>-XX:+UseParallelGC</code></td>
<td>标记-复制算法</td>
<td>多线程</td>
<td></td>
<td>适用于注重系统吞吐量而对响应时间要求相对较低的应用场景</td>
</tr>
<tr>
<td>(5默认)</td>
<td>Parallel Old</td>
<td><code>-XX:+UseParallelOldGC</code></td>
<td>标记-整理算法</td>
<td>多线程</td>
<td></td>
<td>适用于多核服务器，目标是提<strong>高吞吐量</strong></td>
</tr>
<tr>
<td></td>
<td><s>CMS</s></td>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>并发标记-清除算法</td>
<td>多线程</td>
<td>并发</td>
<td>适用于追求低延迟的应用，但可能产生较多的碎片。<strong>内存小低延迟</strong></td>
</tr>
<tr>
<td>7 (9默认)</td>
<td>G1</td>
<td><code>-XX:+UseG1GC</code></td>
<td>标记-整理算法</td>
<td>多线程</td>
<td>并发</td>
<td>适用于大内存的应用，目标是在保持吞吐量的同时降低停顿时间。<strong>内存大低延时</strong></td>
</tr>
<tr>
<td>11(21支持分代)</td>
<td>分代ZGC</td>
<td><code>-XX:+UseZGC -XX:+ZGenerational</code></td>
<td>标记-整理算法</td>
<td>多线程</td>
<td>并发</td>
<td>低延迟</td>
</tr>
</tbody>
</table>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：自适应策略，将设置堆大小的任务交给虚拟机</p>
<h4 id="CMS">CMS</h4>
<p>JDK9 中被弃用</p>
<h5 id="Young-GC-Minor-GC">Young GC/Minor GC</h5>
<p>Minor GC 是针对 GC 堆中年轻代的垃圾回收操作。Eden Region 空间不足触发，将活跃对象 Copy 到 survivor Region 或者直接晋升到 old region 中，空闲的 Region 进入空闲列表等待下一次使用。</p>
<p><strong>常用的调优参数</strong></p>
<p><code>-XX:NewRatio</code>：设置老年代和年轻代的大小比例，默认 2:1</p>
<p><code>-X:SurvivorRatio</code>：设置 Eden 区和一个 Survivor 区 的比值，默认 8:1</p>
<p><code>-XX: MaxTenuringThreshold</code> 默认15，若对象超过年龄阈值则晋升到老年代</p>
<p><code>-XX:+PretenureSizeThreshold</code> 若新创建的对象超过这个阈值则直接晋升到老年代</p>
<p><strong>回收垃圾的算法：</strong></p>
<p>使用标记-复制算法</p>
<h6 id="触发条件">触发条件</h6>
<p>Eden 区空间不足</p>
<h6 id="晋升条件">晋升条件</h6>
<p>从年轻代晋升到老年代</p>
<ul>
<li>经历 MaxTenuringThreshold 次的 Minor GC 后依然存活的对象 <code>--XX:TenuringThreshold</code></li>
<li>新创建的超过 PretenuerSizeThreshold 大小的大对象</li>
<li>Survivor 区中存放不下的对象</li>
</ul>
<h5 id="Full-GC-Major-GC">Full GC/Major GC</h5>
<p>Full GC 是针对整个 GC 堆中新生代和老年代都包括的垃圾回收操作。</p>
<h6 id="触发条件-2">触发条件</h6>
<ul>
<li><strong>老年代空间不足</strong> (在进行一次 Minor GC 时，发现老年代的剩余空间大小小于历次晋升对象的平均大小)</li>
<li><strong>显式调用 <code>System.gc()</code> 方法</strong></li>
<li><strong>在使用 CMS 垃圾收集器时，出现GC失败</strong> (promotion failed 晋升失败，concurrent mode failure 无法在规定时间内完成收集工作)</li>
<li>JDK7 的永久代空间不足 (JDK8 的元空间使用本地内存，不会因空间不足而触发 Full GC)</li>
<li>在使用 RMI(Remote Method Invocation) 远程方法调用来进行 RPC 或管理的 DK(Distributed Key-Value) 分布式键值对应用时，每小时执行1次 Full GC</li>
</ul>
<p><strong>回收垃圾的算法：</strong></p>
<p>在年轻代使用标记-复制算法</p>
<p>在老年代使用标记-整理算法</p>
<p><strong>Full GC 和 Major GC 的区别：</strong></p>
<ul>
<li>Major GC 可以指 Full GC、也可以指老年代 GC (面试需问清楚 Major GC 指什么)</li>
<li>Full GC 比 Minor GC 慢，但执行频率低</li>
</ul>
<h6 id="STW-阶段停顿时间">STW 阶段停顿时间</h6>
<blockquote>
<p>STW暂停 Stop-the-World</p>
<p>在 Full GC 运行时，会在所有应用程序线程到达各自<strong>安全点</strong>后暂停执行，以确保对象在垃圾回收期间不会被并发修改或访问，直到垃圾回收完成。这个暂停的时间被称为<strong>停顿时间</strong>。(在 Minor GC 运行时，只需要停止正在年轻代区域上的所有应用程序线程，不需要安全点)</p>
<p>停顿时间越长，应用程序的响应性就越差，用户可能会感觉到应用程序的卡顿或延迟。</p>
</blockquote>
<p>只有每个线程都到达安全点后 JVM 才执行 Full GC 操作<br>
Safepoint (安全点) 是应用程序线程暂停的位置，暂停应用程序线程后对象引用关系不会发生变化，分析结果具有确定性。</p>
<p>产生安全点的地方：方法调用指令、循环跳转指令、异常跳转指令、主动式安全点等处</p>
<p>安全点数量太少会导致 Full GC 停顿事件太长，安全点数量太多会频繁检测导致程序负荷大。</p>
<h4 id="分代ZGC">分代ZGC</h4>
<p><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/333">JEP333 ZGC</a>	|	<a target="_blank" rel="noopener" href="https://openjdk.org/jeps/439">JEP439 分代ZGC</a>	|	<a target="_blank" rel="noopener" href="https://wiki.openjdk.org/display/zgc#Main-Configuration&amp;Tuning">OpenJDK Wiki#ZGC的配置与调优</a></p>
<p>不分代的问题：OS内存占用(记录卡表)、CPU占用过高</p>
<p>目标 ：<br>
<strong>低延迟(暂停时间不超过1ms)</strong><br>
自动调优auto-tuning(不需要手动配置<code>--Xmn</code>(空闲内存对任何一代可用)、分代规模、线程数<code>--XX:ConcGCThreads</code>、对象停留在年轻代的时间)<br>
可扩展(可处理不同大小的堆 [8MB, 16TB])</p>
<p>使用：<code>java -XX:+UseZGC -XX:+ZGenerational...</code><br>
<code>--Xmx</code><br>
<code>-Xlog:gc</code> 基础日志<br>
<code>-Xlog:gc*</code> 详细日志</p>
<p>自动调优：<br>
动态代大小，不需要指定 <code>--Xmn</code><br>
动态晋升阈值(经过多少次Young GC年轻代中的对象晋升到老年代)，不需要指定 <code>--XX:TenuringThreshold</code><br>
初始化堆占用百分比，不需要指定 <code>--XX:InitiatingHeapOccupancyPercent</code><br>
动态线程数量，不需要指定 <code>-XX:ConcGCThreads</code></p>
<p>核心技术：<br>
ZGC 通过染色指针(colored pointer)、读屏障(load barriers)、存储屏障(store barriers)，为GC线程、并发的应用线程提供一致的对象视图(object graph view)，实现了GC线程与应用程序线程的并发</p>
<p><strong>染色指针</strong>(colored pointer)：64位的指针指向堆中对象，提供<strong>对象地址和元数据位</strong>(remapped, marked0, marked1, Finalizable)，是一种多映射内存技术(Multi-mapped memory)，未分代ZGC将多个虚拟地址指向同一块物理内存<br>
优点：<br>
一个 Region 分区中所有对象重定位后内存空间可以立即被回收和重用，在修复指针(指向被回收/被重用区域)之前，这有助于降低堆开销<br>
减少内存屏障(用于修正指针)的使用数量(降低运行时开销)<br>
具备强大扩展性</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_124923.png" alt="image-20231027124923174" style="zoom:60%;" />
<p>读屏障(load barriers)：是被JIT(即时编译)注入到应用程序的机械指令，更新时指针指向重定位(relocated)对象(重定位时指针不会被急更新，而是当应用遇到该指针时懒更新)</p>
<p>写屏障(store barriers)：保证共享变量的修改可以被其他线程及时感知，帮助标记可达对象(标记loaded对象为alive)</p>
<p>记忆集(remembered-set)：指从老年代到年轻代的指针(old-to-young generation pointers)<br>
卡表标记(card table marking)：通过记忆集合技术，用于跟踪代际间指针(inter-generational pointers)</p>
<p>ZGC阶段：</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115136.png" alt="image-20231027115136375" style="zoom: 45%;" />
<p>同步点：指同步状态发生切换的点，是GC暂停的唯一来源</p>
<table>
    <tr>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115047.png" alt="image-20231027115045462" style="zoom:55%;" /></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115233.png" alt="image-20231027115233605" style="zoom:55%;" /></center></td>
    </tr>
    <tr>
    	<td><center></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115251.png" alt="image-20231027115251210" style="zoom:55%;" /></center></td>
    </tr>
    <tr>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115357.png" alt="image-20231027115357552" style="zoom:55%;" /></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115428.png" alt="image-20231027115428409" style="zoom:55%;" /></center></td>
    </tr>
    <tr>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_122101.png" alt="image-20231027122101547" style="zoom:55%;" /></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115542.png" alt="image-20231027115542004" style="zoom:55%;" /></center></td>
    </tr>
    <tr>
    	<td><center></center></td>
    	<td><center><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_1027_115552.png" alt="image-20231027115552010" style="zoom:55%;" /></center></td>
    </tr>
</table>
<h4 id="年轻代收集器">年轻代收集器</h4>
<h5 id="串行垃圾收集器">串行垃圾收集器</h5>
<p>Serial Garbage Collector 标记-复制算法</p>
<p>说明：它为单线程环境设计，只使用一个单独的线程进行垃圾回收。是 Client 模式默认的年轻代收集器。</p>
<p>使用：通过 JVM 参数 <code>-XX:+UseSerialGC</code> 可以使用串行垃圾回收器。</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_19_57.png" alt="image-20230519195542293" style="zoom:50%;" />
<h5 id="并行垃圾收集器">并行垃圾收集器</h5>
<p>Parallel Scavenge /ˈskævɪndʒ/ 标记-复制算法</p>
<p>说明：使用多线程进行垃圾回收，也会暂停用户线程。</p>
<p>使用：可用 <code>-XX:+UseParallelGC</code> 来强制指定，用 <code>-XX:ParallelGCThreads=4</code>  来指定线程数。</p>
<p>适用于：多CPU，对暂停时间要求暂短的应用</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_19_55.png" alt="image-20230519195507076" style="zoom:50%;" />
<ul>
<li>比起关注用户线程停顿时间，<strong>更关注系统的吞吐量</strong>，适合后台运算不需要交互的程序</li>
<li>在多核下执行才有优势，Server 模式下默认的年轻代收集器</li>
</ul>
<p>(吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间)</p>
<h5 id="新并发垃圾收集器">新并发垃圾收集器</h5>
<p>ParNew Garbage Collector  标记-复制算法</p>
<p>说明：并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。ParNew GC 只会在下面两种情况持有应用程序所有线程。<br>
第一，当标记的引用对象在 Tenured 区域。<br>
第二，在进行垃圾回收的时候堆内存的数据发生改变<br>
相比于Parallel GC，ParNew GC 使用更多的 CPU 来扫描程序，如果能分配为了程序性能更多的 CPU 那么 ParNew 比 Parallel 更好</p>
<p>使用：通过 JVM 参数 <code>XX:+USeParNewGC</code> 打开并发标记扫描垃圾回收器。</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_19_19_55.png" alt="image-20230519195507076" style="zoom:50%;" />
<ul>
<li>多线程收集，其余的行为、特点和 Serial 收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行才有优势，</li>
<li>能与 CMS 配合工作，是 Server 模式下的首选年轻代收集器</li>
<li><strong>以减少 Stop-the-World 为出发点，关注用户线程停顿时间</strong>，适合与用户交互的程序</li>
</ul>
<h4 id="老年代收集器">老年代收集器</h4>
<h5 id="Serial-Old">Serial Old</h5>
<p>(启动参数：<code>-XX:+UseSerialOldGC</code>，标记-整理算法)</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<h5 id="Parallel-Old">Parallel Old</h5>
<p>(启动参数：<code>-XX:+UseParallelOldGC</code>，标记-整理算法)</p>
<ul>
<li>多线程，<strong>吞吐量优先</strong></li>
</ul>
<h5 id="并发标记扫描垃圾收集器">并发标记扫描垃圾收集器</h5>
<p>CMS Concurrent Mark-Sweep 并发标记清除</p>
<p>(启动参数：<code>-XX:+UseConcMarkSweepGC</code>，标记-清除算法)</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_20_16_29.png" alt="image-20230520162923360"></p>
<ul>
<li>
<p><strong>关注用户线程停顿时间</strong></p>
</li>
<li>
<p><strong>初始标记</strong>：stop-the-world</p>
</li>
<li>
<p>并发标记：并发追溯标记，程序不会停顿</p>
</li>
<li>
<p>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</p>
</li>
<li>
<p><strong>重新标记</strong>：stop-the-world 暂停虚拟机，扫描CMS堆中的剩余对象</p>
</li>
<li>
<p>并发清理：清理垃圾对象，程序不会停顿，标记-清除算法</p>
</li>
<li>
<p>并发重置：重置CMS收集器的数据结构</p>
</li>
</ul>
<p>因为 Parallel Scavenge，G1 是独立实现的，其余的共用了框架代码，所以 CMS 不能与 Parallel Scavenge、G1 共用</p>
<h5 id="G1-垃圾收集器">G1 垃圾收集器</h5>
<p>Garbage First 标记-复制+标记-整理算法</p>
<p>说明：G1 收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。<strong>JDK[9+ 成为默认的收集器</strong></p>
<p>使用：通过 JVM 参数 <code>-XX:+UseG1GC</code> 使用G1垃圾回收器，<code>--XX:G1HeapRegionSize</code> 指定Region大小(1,2,4,8,16,32M)。</p>
<p>适用于：堆内存很大的情况</p>
<ul>
<li>将整个 Java 堆内存划分成多个大小相等的区域，并发地进行垃圾回收，在回收内存之后对剩余堆内存空间进行压缩</li>
<li>年轻代和老年代不再物理隔离</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_09_11_01_36.png" alt="image-20230911013623502" style="zoom:80%;" />
<p>Garbage First 收集器的特点：并行和并发、分代收集、碎片整理压缩、可预测的停顿(可设置停顿时间，通过启发式算法设定收集集合)</p>
<p>G1 的三种 GC 模式：</p>
<ul>
<li>
<p>young gc</p>
</li>
<li>
<p>mixed gc<br>
= young + old gc</p>
</li>
</ul>
<p>触发条件：老年代达到整个堆的一个阈值，避免堆内存耗尽</p>
<ul>
<li>full gc</li>
</ul>
<p>单线程执行，暂停时间长，需要不断调优避免 full gc</p>
<p>触发条件：对象分配过快 mixed gc 来不及回收导致老年代被填满</p>
<h3 id="GC-调优">GC 调优</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304">JDK21 GC调优指南(每个版本都有)</a></p>
<h3 id="GC相关的面试题">GC相关的面试题</h3>
<h4 id="finalize-方法的作用">finalize() 方法的作用</h4>
<p>JDK9 中被标记为@Deprecated，JDK11中被弃用</p>
<ul>
<li><strong>与C++的析构函数不同，析构函数调用是确定的，而它的是不确定的</strong></li>
<li>将未被引用的对象放置于 F-Queue 队列</li>
<li><strong>方法执行随时可能会被终止</strong></li>
<li>给予对象最后一次重生的机会</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Finalization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Finalization finalization;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finalized&quot;</span>);</span><br><span class="line">        finalization = <span class="built_in">this</span>;  <span class="comment">// 重生</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 finalize() 运行的不确定性较大，无法各对象的保证顺序，运行代价高，因此不建议使用 finalize() 方法</p>
<h4 id="Java的4种引用">Java的4种引用</h4>
<p>在 java.lang.ref 包下的引用类型</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_06_02_13_42.png" alt="image-20230602134245031" style="zoom: 70%;" />
<p>使用这些引用类型可能会造成内存泄漏或意外的对象回收，在大多数情况下还是用强引用</p>
<h5 id="总结">总结</h5>
<p>值不可变(immutable)</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>回收时机(可达性不同)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>不会</td>
<td>对象的一般状态</td>
</tr>
<tr>
<td>软引用</td>
<td>OOM之前，内存紧张时</td>
<td>对象缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>GC 时</td>
<td>对象缓存</td>
</tr>
<tr>
<td>虚引用</td>
<td>Unknown</td>
<td>标记、哨兵</td>
</tr>
<tr>
<td>引用队列</td>
<td></td>
<td>注册引用到引用队列，请求被通知当对象可达性的变化时</td>
</tr>
</tbody>
</table>
<h5 id="强引用Strong">强引用Strong</h5>
<ul>
<li><strong>最普遍的</strong>引用：<code>Object obj = new Object()</code>，obj 是引用对象(reference object)，new Object是引用实例(referent)</li>
<li>回收时机：即使抛出 OOM，GC 也不会回收被强引用的关联着的对象</li>
<li>通过将对象设置为 null 来弱化引用，使其被回收</li>
</ul>
<h5 id="软引用Soft">软引用Soft</h5>
<ul>
<li>对象处在有用但非必须的状态</li>
<li>回收时机：只有快要 OOM 之前之前，GC 才会回收被软引用的关联着的对象</li>
<li>可以<strong>用来实现高速缓存</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;string&gt;softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;string&gt;(str);  <span class="comment">// 包装为软引用</span></span><br></pre></td></tr></table></figure>
<h5 id="弱引用Weak">弱引用Weak</h5>
<ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>回收时机：无论内存是否紧缺，GC 时都会回收被弱引用的关联着的对象</li>
<li>被回收的概率也不大，因为 GC 线程优先级比较低</li>
<li>适用于引用偶尔被使用且不影响垃圾收集的对象</li>
</ul>
<p><strong>问题案例：</strong><br>
利用软引用和弱引用解决 OOM 问题：假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p>
<p>设计思路是：用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题。</p>
<p>示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalObjectWeakReference</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;NormalObject&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 构造函数用来初始化成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NormalObjectWeakReference</span><span class="params">(NormalObject normalObject, ReferenceQueue&lt;NormalObject&gt; rq)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(normalObject, rq);</span><br><span class="line">        <span class="built_in">this</span>.name = normalObject.name;</span><br><span class="line">&#125;	&#125;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NormalObject</span> <span class="variable">nobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalObject</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;string&gt;abcWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;string&gt;(nobj);  <span class="comment">// 包装为弱引用</span></span><br></pre></td></tr></table></figure>
<h5 id="虚引用Phantom">虚引用Phantom</h5>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起<strong>哨兵</strong>作用</li>
<li>必须和引用队列 Reference Queue 联合使用</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 强引用</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str,queue);  <span class="comment">// 包装为虚引用</span></span><br></pre></td></tr></table></figure>
<h5 id="引用队列ReferenceQueue">引用队列ReferenceQueue</h5>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li>
<li><strong>GC 完成后，ReferenceQueue 会存储，与被回收的软、弱、虚引用实例 referent 相关联的 reference object 引用对象</strong></li>
</ul>
<p>如果实例被回收，则 reference 对象会被放进 ReferenceQueue。倘若没有 ReferenceQueue，则只能轮询 reference 对象再通过 get 是否返回空判断实例是否被回收。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;NormalObject&gt; rq = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;NormalObject&gt;();  <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历引用队列rq，检查rq中是否有对象，如果有，打印出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Reference&lt;NormalObject&gt; ref = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ref = (Reference&lt;NormalObject&gt;)rq.poll()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In queue: &quot;</span> + ((NormalObjectWeakReference)(ref)).name);</span><br><span class="line">                System.out.println(<span class="string">&quot;reference object:&quot;</span> + ref.get());  <span class="comment">// 返回引用对象所指向的引用实例</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建3个弱引用放入ArrayList容器</span></span><br><span class="line">        ArrayList&lt;WeakReference&lt;NormalObject&gt;&gt; weakList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WeakReference&lt;NormalObject&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            weakList.add(<span class="keyword">new</span> <span class="title class_">NormalObjectWeakReference</span>(<span class="keyword">new</span> <span class="title class_">NormalObject</span>(<span class="string">&quot;Weak &quot;</span> + i),rq));</span><br><span class="line">            System.out.println(<span class="string">&quot;Created weak:&quot;</span> + weakList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 第一次，遍历引用队列rq</span></span><br><span class="line">        System.out.println(<span class="string">&quot;first time&quot;</span>);</span><br><span class="line">        checkQueue();  <span class="comment">// 说明此时 rq 为空</span></span><br><span class="line">        <span class="comment">// 回收 NormalObjectWeakReference 弱引用</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次，遍历引用队列rq</span></span><br><span class="line">        System.out.println(<span class="string">&quot;second time&quot;</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java工具">Java工具</h2>
<table>
<thead>
<tr>
<th>以前的 Java 工具</th>
<th>命令文档</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/jps.html">文档</a></td>
<td>列出目标系统上已检测的 JVM，列出PID</td>
</tr>
<tr>
<td>jinfo</td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/jinfo.html">文档</a></td>
<td>生成指定 Java 进程的 Java 配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/jmap.html">文档</a></td>
<td>打印指定进程的详细信息</td>
</tr>
<tr>
<td>jstat</td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/jstat.html">文档</a></td>
<td>监控 JVM 统计信息</td>
</tr>
<tr>
<td>jstack</td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/jstack.html">文档</a></td>
<td>打印指定 Java 进程的 Java 线程的 Java 堆栈跟踪</td>
</tr>
</tbody>
</table>
<h3 id="javac">javac</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/javac.html">文档</a></p>
<p>读取 Java 源代码中类和接口定义，编译为 Class 字节码文件，其中的 class 文件常量池中含有字面量和符号引用。添加静态常量成员变量 <code>Classname.class</code>，用于指向该类的Class对象，同时添加无参构造方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-8 &lt;options&gt; &lt;<span class="built_in">source</span> files&gt;</span><br></pre></td></tr></table></figure>
<h3 id="java">java</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/20/docs/specs/man/java.html">文档</a>	|	<a target="_blank" rel="noopener" href="https://chriswhocodes.com/hotspot_options_openjdk21.html">VM 选项</a>	|	<a target="_blank" rel="noopener" href="https://jacoline.dev/inspect">Java 命令行检查(用于优化 Java 命令行)</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java [options] &lt;主类&gt; [args...]  <span class="comment"># 执行类，主类为全类名(不需要后缀)</span></span><br><span class="line">$ java [options] -jar &lt;jar 文件&gt; [args...]  <span class="comment"># 模块运行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:&lt;jar 路径&gt;[=&lt;选项&gt;]  <span class="comment"># 加载 Java 代理/探针程序(java.lang.instrument实现)到 JVM 中，用于性能分析、字节码增强、动态代码注入</span></span><br></pre></td></tr></table></figure>
<h4 id="JVM-的运行模式">JVM 的运行模式</h4>
<p>Client 模式：启动快，程序运行慢，轻量级VM，<strong>JDK9 被弃用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -client YourApp</span><br></pre></td></tr></table></figure>
<p>Server 模式：启动慢，程序运行快，重型VM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -server YourApp</span><br></pre></td></tr></table></figure>
<h3 id="javap">javap</h3>
<p>对Class文件反汇编，用于查看字节码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose &lt;classes&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteCodeSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c ByteCodeSample.<span class="keyword">class</span>  </span><br><span class="line"><span class="title class_">Compiled</span> from <span class="string">&quot;ByteCodeSample.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.interview.javabasic.bytecode.ByteCodeSample &#123;</span><br><span class="line">  <span class="keyword">public</span> com.interview.javabasic.bytecode.ByteCodeSample();  <span class="comment">// 无参构造方法</span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  <span class="comment">// 加载句柄</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V  // 调用父类构造初始化</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:  <span class="comment">// Java虚指令</span></span><br><span class="line">       <span class="number">0</span>: iconst_1  <span class="comment">// 常量1压入-&gt;操作数栈</span></span><br><span class="line">       <span class="number">1</span>: istore_1  <span class="comment">// 操作数栈pop-&gt;局部变量表[1]</span></span><br><span class="line">       <span class="number">2</span>: iconst_5  <span class="comment">// 常量5压入-&gt;操作数栈</span></span><br><span class="line">       <span class="number">3</span>: istore_2  <span class="comment">// 操作数栈pop-&gt;局部变量表[2]</span></span><br><span class="line">       <span class="number">4</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">7</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">10</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;  // 获取静态域</span></span><br><span class="line">      <span class="number">13</span>: iload_1  <span class="comment">// 局部变量表[1]压入-&gt;操作数栈</span></span><br><span class="line">      <span class="number">14</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V  // 调用println</span></span><br><span class="line">      <span class="number">17</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">20</span>: iload_2  <span class="comment">// 局部变量表[2]压入-&gt;操作数栈</span></span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JConsole">JConsole</h3>
<p>Java Monitoring and Management Console，有 GUI 界面</p>
<h3 id="arthas">arthas</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/arthas/blob/master/README_CN.md">github</a></p>
<h3 id="mat">mat</h3>
<p>堆内存分析工具</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.haruharu.top">Nemesis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.haruharu.top/articles/Dev/language/Java/VM/JVM/">https://blog.haruharu.top/articles/Dev/language/Java/VM/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.haruharu.top" target="_blank">Nemesis</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/articles/Dev/language/Java/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="Java反射机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java反射机制</div></div></a></div><div class="next-post pull-right"><a href="/articles/Dev/language/Java/%E7%B1%BB%E5%BA%93APIs/Java%E7%9A%84IO%E6%9C%BA%E5%88%B6/" title="JavaIO机制"><img class="cover" src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_07_12_01_09.png&quot; alt=&quot;image-20230712010935842" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaIO机制</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nemesis</div><div class="author-info__description">浙江外国语学院大四老人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" href="mailto:chenxiangcheng1@gmail.com"><i class="fas fa-envelope"></i><span>Contact Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxiangcheng1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chenxiangcheng1@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/36033539" target="_blank" title="Bili"><i class="fa-brands fa-bilibili" style="color: #74C0FC;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">有空B站直播写代码 ( •̀ ω •́ )✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">JVM主要考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HotSpot-VM-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1 HotSpot VM 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">类从编译到执行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">Native 原生方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.2.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.</span> <span class="toc-text">执行引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ClassLoader"><span class="toc-number">1.4.</span> <span class="toc-text">2 ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ClassLoader-%E5%8F%AF%E4%BD%BF%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">自定义 ClassLoader 可使用字节码增强技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%A3%85%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">类的装载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%A3%85%E8%BD%BD%E5%92%8C%E9%9A%90%E5%BC%8F%E8%A3%85%E8%BD%BD"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">显示装载和隐式装载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#loadClass-%E5%92%8C-forName-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">loadClass 和 forName 的区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">3 Java内存区域划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E9%83%A8%E5%88%86-%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">线程私有部分 (本地内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SOF-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%81OOM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.1.1.1.</span> <span class="toc-text">SOF 栈溢出异常、OOM 内存溢出异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E9%83%A8%E5%88%86-%E4%B8%BB%E5%86%85%E5%AD%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程共享部分 (主内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4-%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">元空间 使用本地内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E5%A0%86"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">GC堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GC-%E5%A0%86%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86-%E9%87%8D%E7%82%B9"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">GC 堆内存区域的划分(重点)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">常考题解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">三大性能调优参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">堆和栈的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-%E9%87%8D%E7%82%B9-%EF%BC%9A"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">区别 (重点)：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E5%85%83%E7%A9%BA%E9%97%B4-%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6"><span class="toc-number">1.5.3.2.2.</span> <span class="toc-text">栈、堆、元空间(内存角度)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-GC-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">4 GC 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%A0%86%E4%B8%AD%E6%A0%87%E8%AE%B0%E5%BC%BA%E5%BC%95%E7%94%A8%E5%9E%83%E5%9C%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">GC堆中标记强引用垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">可达性分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%A0%87%E8%AE%B0%E5%9E%83%E5%9C%BE"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">方法区标记垃圾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E7%9A%844%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">回收垃圾的4种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">常见的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">CMS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Young-GC-Minor-GC"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">Young GC&#x2F;Minor GC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.6.3.1.1.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%99%8B%E5%8D%87%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.6.3.1.1.2.</span> <span class="toc-text">晋升条件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Full-GC-Major-GC"><span class="toc-number">1.6.3.1.2.</span> <span class="toc-text">Full GC&#x2F;Major GC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6-2"><span class="toc-number">1.6.3.1.2.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#STW-%E9%98%B6%E6%AE%B5%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4"><span class="toc-number">1.6.3.1.2.2.</span> <span class="toc-text">STW 阶段停顿时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3ZGC"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">分代ZGC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">年轻代收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.3.1.</span> <span class="toc-text">串行垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.3.2.</span> <span class="toc-text">并行垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%B9%B6%E5%8F%91%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.3.3.</span> <span class="toc-text">新并发垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">老年代收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Old"><span class="toc-number">1.6.3.4.1.</span> <span class="toc-text">Serial Old</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Old"><span class="toc-number">1.6.3.4.2.</span> <span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%89%AB%E6%8F%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.4.3.</span> <span class="toc-text">并发标记扫描垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.4.4.</span> <span class="toc-text">G1 垃圾收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E8%B0%83%E4%BC%98"><span class="toc-number">1.6.4.</span> <span class="toc-text">GC 调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">GC相关的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">finalize() 方法的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">Java的4种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.5.2.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8Strong"><span class="toc-number">1.6.5.2.2.</span> <span class="toc-text">强引用Strong</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8Soft"><span class="toc-number">1.6.5.2.3.</span> <span class="toc-text">软引用Soft</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8Weak"><span class="toc-number">1.6.5.2.4.</span> <span class="toc-text">弱引用Weak</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8Phantom"><span class="toc-number">1.6.5.2.5.</span> <span class="toc-text">虚引用Phantom</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97ReferenceQueue"><span class="toc-number">1.6.5.2.6.</span> <span class="toc-text">引用队列ReferenceQueue</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B7%A5%E5%85%B7"><span class="toc-number">1.7.</span> <span class="toc-text">Java工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javac"><span class="toc-number">1.7.1.</span> <span class="toc-text">javac</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java"><span class="toc-number">1.7.2.</span> <span class="toc-text">java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">JVM 的运行模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javap"><span class="toc-number">1.7.3.</span> <span class="toc-text">javap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JConsole"><span class="toc-number">1.7.4.</span> <span class="toc-text">JConsole</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arthas"><span class="toc-number">1.7.5.</span> <span class="toc-text">arthas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mat"><span class="toc-number">1.7.6.</span> <span class="toc-text">mat</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/articles/%E4%BA%8C%E7%BA%A7%E5%B8%82%E5%9C%BA/%E8%80%83%E8%AF%95/%E5%9F%BA%E4%BB%8E/" title="基金从业资格证">基金从业资格证</a><time datetime="2024-06-01T16:00:00.000Z" title="发表于 2024-06-02 00:00:00">2024-06-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/articles/Dev/language/small-language/YAML1.2/" title="YAML">YAML</a><time datetime="2024-04-19T16:00:00.000Z" title="发表于 2024-04-20 00:00:00">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/Dev/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Nginx/" title="Nginx"><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_09_25_08_26_56.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/articles/Dev/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Nginx/" title="Nginx">Nginx</a><time datetime="2024-03-17T16:00:00.000Z" title="发表于 2024-03-18 00:00:00">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/Dev/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="桥接模式"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="桥接模式"/></a><div class="content"><a class="title" href="/articles/Dev/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="桥接模式">桥接模式</a><time datetime="2024-03-12T16:00:00.000Z" title="发表于 2024-03-13 00:00:00">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/Dev/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式"><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2024_0308_133937.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="抽象工厂模式"/></a><div class="content"><a class="title" href="/articles/Dev/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式">抽象工厂模式</a><time datetime="2024-03-07T16:00:00.000Z" title="发表于 2024-03-08 00:00:00">2024-03-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_13_14_00.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Nemesis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'ChenXiangcheng1/chenxiangcheng1.github.io',
      'data-repo-id': 'R_kgDOJEy5Dw',
      'data-category-id': 'DIC_kwDOJEy5D84CfyxF',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },{"data-mapping":"title","data-input-position":"bottom"})

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="https://cdn.jsdelivr.net/gh/Pil0tXia/busuanzi-modified/busuanzi.pure.mini.js"></script></div></body></html>