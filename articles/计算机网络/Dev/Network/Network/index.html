<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机网络 | Nemesis</title><meta name="author" content="Nemesis,chenxiangcheng1@gmail.com"><meta name="copyright" content="Nemesis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要是计算机网络相关知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://blog.haruharu.top/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Dev/Network/Network/">
<meta property="og:site_name" content="Nemesis">
<meta property="og:description" content="主要是计算机网络相关知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_19.gif">
<meta property="article:published_time" content="2023-04-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-26T14:20:39.145Z">
<meta property="article:author" content="Nemesis">
<meta property="article:tag" content="博客,ACM,技术,开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_19.gif"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://blog.haruharu.top/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Dev/Network/Network/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-26 22:20:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_19.gif')"><nav id="nav"><span id="blog-info"><a href="/" title="Nemesis"><span class="site-name">Nemesis</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-30T16:00:00.000Z" title="发表于 2023-05-01 00:00:00">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-26T14:20:39.145Z" title="更新于 2024-05-26 22:20:39">2024-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络主要考点"><a href="#计算机网络主要考点" class="headerlink" title="计算机网络主要考点"></a>计算机网络主要考点</h1><h2 id="OSI-和-TCP-IP"><a href="#OSI-和-TCP-IP" class="headerlink" title="OSI 和 TCP&#x2F;IP"></a>OSI 和 TCP&#x2F;IP</h2><p><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_19.gif" alt="1953408-20210620133658723-1723136444"></p>
<table>
<thead>
<tr>
<th>OSI 参考模型</th>
<th>主要作用(每一层都上层提供服务且透明)</th>
<th>常见协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>准备数据，提供应用程序间通信，为应用程序提供<strong>网络接口</strong></td>
<td>HTTP、SSH、DHCP</td>
</tr>
<tr>
<td>表示层</td>
<td>在传输之前处理数据的格式：进行数据<strong>压缩&#x2F;还原</strong>、数据<strong>加&#x2F;解密</strong>(二进制、编码格式ascii)</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>建立、维护和管理会话。即在两个互相通信的进程之间对传输的报文提供<strong>同步管理</strong>服务</td>
<td>TLS、SSL</td>
</tr>
<tr>
<td>传输层</td>
<td>建立<strong>端到端</strong>的连接，提供两端应用程序的通信。可靠传输(分段编号)&#x2F;不可靠传输、流量控制</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td><strong>点对点</strong>，寻址和路由选择(选择路由路径)</td>
<td>IP、ICMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>提供介质访问、链路管理(在网络节点间的线路上传送<strong>数据帧</strong>)</td>
<td>ARP</td>
</tr>
<tr>
<td>物理层</td>
<td>在传输媒体上传输<strong>比特流</strong>、定义了网络设备的机械特性,接口标准,电器标准,过程特性</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>TCP&#x2F;IP 协议栈</th>
<th>物理层和数据链路层的底层的协议由网卡NIC通过硬件实现<br/>网络层、传输层的协议由操作系统实现并向应用层提供socket接口</th>
<th>默认端口号</th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用层</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>HTTP</strong> (HyperText Transfer Protocol) 超文本传输协议</td>
<td>基于TCP，默认使用80号端口<br />是从 WWW 服务器传输超文本到本地浏览器时所使用的传输协议，无状态的<br />无状态的意思是其数据包的发送、传输和接收都是相互独立的。<br/>无连接的意思是指通信双方都不长久的维持对方的任何信息。</td>
<td>80</td>
</tr>
<tr>
<td><strong>SSH</strong> (Secure Shell) 安全外壳协议</td>
<td>基于TCP，默认使用22号端口<br />主要用于远程登录和文件传输</td>
<td>22</td>
</tr>
<tr>
<td><strong>DNS</strong> (Domain Name System) 域名解析</td>
<td>基于UDP，默认使用53号端口<br/>本地服务器要配置 DNS 服务器地址，通过 DNS 服务器解析域名得到 IP 地址</td>
<td>53</td>
</tr>
<tr>
<td><strong>DHCP</strong> (Dynamic Host Configuration Protocol) 动态主机配置协议</td>
<td>基于UDP，默认使用67(DHCP server)，68(DHCP client)端口<br />为 DHCP 客户端配置网关地址、DNS 服务器地址、动态分配 IP 地址</td>
<td>67</td>
</tr>
<tr>
<td>SMTP(Simple Mail Transfer Protocol)简单邮件传输协议</td>
<td>基于TCP，使用25号端口，是一组用于由源地址到目的地址传送邮件的规范，用来控制信件的发送、中转的方式，帮助在发送或中转信件时找到下一个目的地，SMTP服务器就是遵循SMTP协议的发送邮件的服务器</td>
<td>25</td>
</tr>
<tr>
<td>FTP文件传输协议，File Transfer Protocol</td>
<td>基于TCP，一般上传下载用FTP服务，数据端口是20号，控制端口是21号</td>
<td>20、21</td>
</tr>
<tr>
<td>TELNET：远程登入协议</td>
<td>基于TCP，使用23号端口，是Internet远程登录服务器的标准协议和主要方式。为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序连接到服务器。使用明码传送，保密性差，不安全，但简单方便，专门为局域网设计</td>
<td>23</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>TCP</strong>：传输控制协议，Transmission Control Protocol</td>
<td><strong>面向连接的</strong>(三次握手四次挥手)、字节流、<strong>可靠的</strong> (数据按序到达、确认重传机制)、流量控制 (滑动窗口机制)、<strong>全双工</strong>。适用于对差错不敏感的或对性能要求高的实时的业务</td>
<td></td>
</tr>
<tr>
<td><strong>UDP</strong>：用户数据报协议，User Datagram Protocol</td>
<td><strong>面向无连接</strong>，面向消息，<strong>不可靠的</strong>(可靠性由上层协议保障)。适用于对性能要求高，对数据正确性要求不高的或者需要多播广播的业务。</td>
<td></td>
</tr>
<tr>
<td>TLS (Transport Layer Security)</td>
<td>是SSL(Secure Sockets Layer)的标准化版本<br />主要用于Web浏览器和服务器之间的安全通信</td>
<td></td>
</tr>
<tr>
<td>SCTP：流量传输控制协议</td>
<td>一种面向连接的流传输协议，SCTP虽然在首发两端有多条路径，但实际只是使用一条路径传输，当该条路径出现故障时，不需要断开连接，而是转移到其他路径</td>
<td></td>
</tr>
<tr>
<td>MPTCP：多路径传输控制协议</td>
<td>TCP的多路径版本，MPTCP真正意义上实现了多路径并行传输，在链接建立阶段，建立多条路径，然后使用多条路径同时传输数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>IP</strong> (Internet Protocol)</td>
<td>是 TCP&#x2F;IP 协议簇中最为核心的协议，所有的上层协议都以 IP 数据包的格式传输<br/>不可靠：不保证数据包成功到达目的地，对于数据传输过程的错误数据包，IP协议将会进行丢弃<br/>无连接：对数据包处理是独立进行的，也不按发送顺序接收</td>
<td></td>
</tr>
<tr>
<td><strong>ICMP</strong> (Internet Control Message Protocol)</td>
<td>用于传递控制消息、Ping目标主机是否可达</td>
<td></td>
</tr>
<tr>
<td><strong>ARP</strong> (Address Resolution Protocol) 地址解析协议</td>
<td>将目标设备的 IP 地址通过局域网广播，解析目标 MAC 地址</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>链路层</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手的过程-基础"><a href="#三次握手的过程-基础" class="headerlink" title="三次握手的过程 (基础)"></a>三次握手的过程 (基础)</h3><p><strong>在TCP&#x2F;IP协议中，TCP协议提供可靠的连接 (Socket)服务，采用三次握手建立一个连接。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_41.png" alt="image-20230501154151616"></p>
<p>第一次握手<br><strong>准备建立连接。客户端发送SYN包(同步标志为1，序列号为x)，客户端进入同步发送状态，等待服务器的确认</strong></p>
<p>第二次握手<br><strong>服务端发送SYN+ACK包，服务端进入同步收到 syn-received 半连接状态</strong></p>
<p>第三次握手<br><strong>客户端发送ACK包，进入连接建立状态。收到报文服务器端进入连接建立状态，完成TCP三次握手</strong></p>
<p>seq序列号Sequence Number<br>SYN同步报文段，同步标志<br>ACK应答报文段<br>ack应答序列号Acknowledgment Number</p>
<blockquote>
<p>准备建立连接，服务端开始监听。<br>第一次握手，客户端发送SYN同步包，进入 SYN-send 状态。<br>第二次握手，服务端收到SYN包，并发送SYN加ACK同步应答包，进入 SYN-received 半连接状态。<br>第三次握手，客户端收到SYN加ACK包，并发送ACK应答包，进入连接建立状态。<br>服务端收到ACK包后也进入连接建立状态，完成TCP三次握手。</p>
</blockquote>
<h4 id="为什么要第三次握手"><a href="#为什么要第三次握手" class="headerlink" title="为什么要第三次握手"></a>为什么要第三次握手</h4><p><strong>因为存在请求包超时的情况</strong>。为了防止已失效的超时的请求连接报文段突然又传送到了服务端，因而产生错误。</p>
<p><strong>当</strong>客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务端。本来这是一个早已失效的报文段。但服务端收到此失效的连接请求报文段后，就<strong>误认为是客户端再次发出的一个新的连接请求</strong>。于是就向客户端发出确认报文段，同意建立连接。<br>        <strong>假设</strong>不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。<br>        <strong>假设</strong>采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”三次握手就是为了把是否连接的决定权交给client，在双方都确认对方准备好了才开始</p>
<blockquote>
<p>为了避免超时的请求包被误认为是新的连接请求。</p>
</blockquote>
<h3 id="TCP的-SYN-Cookie-机制"><a href="#TCP的-SYN-Cookie-机制" class="headerlink" title="TCP的 SYN Cookie 机制"></a>TCP的 SYN Cookie 机制</h3><p>SYN Flood 攻击会伪造 SYN 包，占用服务器资源，有63秒的半连接状态。</p>
<p>针对 SYN Flood 的防护措施有 SYN Cookie 机制<br><strong>TCP 的 SYN Cookie 机制</strong>：当服务端 SYN 队列满后，通过 tcp_syncookies 参数向客户端发送 SYN Cookie。若该客户端为正常连接则会向服务器回发 SYN Cookie，<strong>能直接建立连接</strong>。</p>
<h3 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h3><p>向客户端发送保活深测报文，若未收到响应则继续发送。若尝试次数达到保活探测数，但是仍未收到响应则中断该连接。</p>
<h3 id="四次挥手的过程-基础"><a href="#四次挥手的过程-基础" class="headerlink" title="四次挥手的过程 (基础)"></a>四次挥手的过程 (基础)</h3><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_16_24.png" alt="image-20230501162443442" style="zoom:80%;" />

<p>使用 Linux 命令: <code>netstat -n | awk &#39;/^tcp/&#123;++S[$NF]&#125;END&#123;for(a in S) print a,S[a]&#125;&#39; </code> 查看服务器TCP连接状态数</p>
<p>第一次挥手<br><strong>主机1 (客户端或服务器端)，发送FIN报文，进入FINAL WAIT状态</strong></p>
<p>第二次挥手<br><strong>主机2发送ACK报文，进入CLOSE WAIT状态</strong></p>
<p>第三次挥手<br><strong>主机2发送FIN报文，进入LAST ACK状态</strong></p>
<p>第四次挥手<br><strong>主机1发送ACK报文，进入TIME WAIT状态。主机2收到应答报文进入CLOSE状态，主机1等待两倍的最长报文寿命(30s)进入CLOSE状态。</strong></p>
<blockquote>
<p>第一次挥手，客户端发送FIN终止包，进入 final-wait 状态。<br>第二次挥手，服务端收到FIN包，并发送ACK应答包，进入close-wait 状态。<br>第三次挥手，服务端发送FIN终止包，进入 last-ack 状态。<br>第四次挥手，客户端收到上面ACK包和FIN包，并发送给服务端一个ACK包，进入 time-wait 状态，等待两倍的MSL最长报文寿命时间后进入 Close 状态。<br>服务端收到ACK包后也进入 Close 状态。完成TCP四次挥手。</p>
</blockquote>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>因为TCP是<strong>全双工模式</strong>的，所以客户端和服务端都需要发送FIN报文和ACK报文</p>
<h4 id="为什么连接三次握手，关闭却是四次挥手"><a href="#为什么连接三次握手，关闭却是四次挥手" class="headerlink" title="为什么连接三次握手，关闭却是四次挥手"></a>为什么连接三次握手，关闭却是四次挥手</h4><p>当请求连接时，服务端把SYN和ACK放一个报文里发给客户端<br>当关闭连接时，服务端不会立即关闭SOCKET连接，会先回复ACK报文，再<strong>由应用层决定发送FIN报文</strong></p>
<h4 id="为什么主机1要有TIME-WAIT状态"><a href="#为什么主机1要有TIME-WAIT状态" class="headerlink" title="为什么主机1要有TIME_WAIT状态"></a>为什么主机1要有TIME_WAIT状态</h4><p><strong>存在应答报文丢失的情况</strong></p>
<p><strong>当</strong>主机1发送的应答报文丢失，主机2会再次发送FIN片段<br>        <strong>假设</strong>不采用TIME WAIT状态，则主机2会一直等待应答报文<br>        <strong>假设</strong>主机1处于TIME WAIT状态，可以再次发送应答报文。就是延迟关闭，确保主机1和主机2都关闭了。</p>
<blockquote>
<p>因为当客户端的ACK应答包丢失，服务端会再次发送FIN终止包。<br>两倍的MSL时间的延迟关闭，能够确保服务端已经关闭了再关闭自己。</p>
</blockquote>
<h4 id="服务器出现大量-CLOSE-WAIT-状态的原因"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因"></a>服务器出现大量 CLOSE_WAIT 状态的原因</h4><p>原因：对方关闭scocket连接，我方忙于读或写，没有及时关闭连接 (没有及时发送FIN终止包)<br>解决：检查代码，特别是<strong>释放资源</strong>的代码、检查配置，特别是处理请求的线程配置</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>连接：TCP面向连接、UDP无连接适合消息<strong>多播</strong><br><strong>可靠性：TCP有握手机制、重传机制</strong><br>有序性：TCP有序列号<br>速度：UDP适合媒体、多人在线游戏<br>量级：TCP20字节、UDP8字节</p>
<h3 id="TCP流量控制-滑动窗口机制"><a href="#TCP流量控制-滑动窗口机制" class="headerlink" title="TCP流量控制 滑动窗口机制"></a>TCP流量控制 滑动窗口机制</h3><p>TCP流量控制：是指通过滑动窗口机制来控制发送方的数据发送速率，从而确保接收方能够及时处理这些数据。</p>
<blockquote>
<p>滑动窗口机制</p>
<p>TCP滑动窗口机制是建立在确认重传机制上的<br>接收方接受窗口的大小等于最大接收缓存减发送方已发送但自己未接受的大小<br>当接收方收到数据后，会向发送方发送一个ACK确认包并告诉发送方自己当前的接收窗口大小。<br>发送方的发送窗口大小就等于接收窗口大小减去已发送但未确认的大小。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_02_20_18.png" alt="image-20230502201834857" style="zoom:80%;" />

<p>发送窗口只有收到接收方的ACK确认(累计确认)才会移动发送窗口的左边界</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_02_20_19.png" alt="image-20230502201853949" style="zoom:80%;" />

<p>接收窗口只有在前面所有的段都确认的情况下才移动左边界</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_02_20_22.png" alt="image-20230502202232177" style="zoom:40%;" />

<p>rwnd 接收窗口大小 &#x3D; 最大的接收缓存 - (发送方已发送且未接受)<br>swnd 发送窗口大小 &#x3D; 接收窗口大小 - (发送未确认)</p>
<h3 id="TCP拥塞控制-拥塞窗口"><a href="#TCP拥塞控制-拥塞窗口" class="headerlink" title="TCP拥塞控制 拥塞窗口"></a>TCP拥塞控制 拥塞窗口</h3><p>TCP拥塞控制：是指通过不同的机制来控制发送方的数据发送速率 (<strong>swnd &#x3D; min(rwnd, cwnd)</strong>)，从而<strong>避免超时重传</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_07_19_00_26.png" alt="image-20230719002559415" style="zoom:80%;" />

<p><strong>慢启动策略</strong>：TCP连接刚开始时 (cwnd 拥塞窗口 &lt; ssthresh slow start threshold) ，cwnd 会以指数级增加，直到网络出现拥塞为止。</p>
<p><strong>拥塞避免策略</strong>：在慢启动结束后 (cwnd &gt; ssthresh) 使用，cwnd 会以线性增加的方式调整发送速率，以避免网络拥塞。</p>
<p>当发送超时重传，ssthresh &#x3D; cwnd&#x2F;2，cwnd &#x3D; 1</p>
<p><strong>快速重传策略</strong>：发送方收到三个连续的重复 ACK 确认，就立即重传丢失的数据包，而不是超时重传。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_07_19_00_25.png" alt="image-20230719002548631"></p>
<p><strong>快速恢复策略</strong>：发送方收到三个连续的重复 ACK 确认，ssthresh &#x3D; cwnd，cwnd &#x3D; cwnd&#x2F;2，跳过慢开始。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HyperText Transfer Protocol 超文本传输协议</p>
<p>是所有www文件(html、css、js、png、mp4、text、pdf…)请求和应答的标准</p>
<p>以 ASCII 码传输</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><p>HTTP&#x2F;2<br>多路复用</p>
<p>HTTP&#x2F;3<br>基于UDP<br>使用QUIC协议保证可靠传输<br>测试：<a target="_blank" rel="noopener" href="https://quic.nginx.org/quic.html">https://quic.nginx.org/quic.html</a></p>
<h3 id="1请求与响应过程"><a href="#1请求与响应过程" class="headerlink" title="1请求与响应过程"></a>1请求与响应过程</h3><ol>
<li><strong>DNS解析</strong>：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存(通过DHCP得到)、根域名服务器缓存、顶级域名服务器缓存</li>
<li><strong>TCP连接建立会话</strong>：三次握手</li>
<li><strong>发送HTTP请求报文</strong></li>
<li><strong>服务器处理请求并返回HTTP响应报文</strong></li>
<li><strong>浏览器解析渲染页面</strong></li>
<li><strong>关闭连接</strong>：四次挥手</li>
</ol>
<p>ARP广播得到目标MAC地址</p>
<h3 id="2请求报文"><a href="#2请求报文" class="headerlink" title="2请求报文"></a>2请求报文</h3><p>HTTP请求报文 &#x3D; 请求行 + 请求头 + 请求正文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET请求</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1		（这是请求行，请求方法：GET，请求地址URI：/，HTTP协议版本：HTTP/1.1）</span><br><span class="line">Host: www.imooc.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Content-Length: 612						(这两项可以关注一下)</span><br><span class="line">Content-Type: application/csp-report	(这两项可以关注一下)</span><br><span class="line">Cookie: zg_did=%7B%22did%22%3A%20%2217009bab896318-048a9423947a59-b383f66-144000-17009bab897b54%22%7D; imooc_uuid=f4c4e666-7e46-450e-9ccf-83971de1f578; imooc_isnew_ct=1580711197; imooc_isnew=2; UM_distinctid=17014351aac33e-058c4c3fa0427d-b383f66-144000-17014351aad849; loginstate=1; apsid=Q4NzY1MTJkYzY3NWFjMDM1OWJkMWEzNzJjOTliNWYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODIwMTcyMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzb2Z0cHl0aG9uQUlAMTYzLmNvbQAAAAAAAAAAAAAAADQyNzE5NDM0YjRhMmQ1MDNiNTc1NzJlMTNiODE1OTgAAQJBXgECQV4%3DMz; last_login_username=softpythonAI%40163.com; adv_#globalTopBanner_2749=1581569592688; Hm_lvt_f0cfcccd7b1393990c78efdeebff3968=1581309568,1581503187,1581569540,1581655164; IMCDNS=0; Hm_lpvt_f0cfcccd7b1393990c78efdeebff3968=1581696480; zg_f375fe2f71e542a4b890d9a620f9fb32=%7B%22sid%22%3A%201581696026643%2C%22updated%22%3A%201581696533607%2C%22info%22%3A%201581318647072%2C%22superProperty%22%3A%20%22%7B%5C%22%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%5C%22%3A%20%5C%22%E8%B7%AF%E5%BE%84%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%5C%22%2C%5C%22Platform%5C%22%3A%20%5C%22web%5C%22%7D%22%2C%22platform%22%3A%20%22%7B%7D%22%2C%22utm%22%3A%20%22%7B%7D%22%2C%22referrerDomain%22%3A%20%22class.imooc.com%22%2C%22cuid%22%3A%20%22w6yyP76B_Ss%2C%22%2C%22zs%22%3A%200%2C%22sc%22%3A%200%2C%22firstScreen%22%3A%201581696026643%7D; cvde=5e4618736308b-131	（这是消息报头,包含有关客户端环境及请求正文的信息，如请求正文长度、浏览器所用编码格式等）</span><br><span class="line">     (空行)</span><br><span class="line">(没有请求正文)</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_03_23_10.png" alt="image-20230503231024088" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>请求格式</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>请求行</td>
<td>包含请求方法、请求地址和HTTP协议版本</td>
</tr>
<tr>
<td>请求头部\消息报头</td>
<td>包含一系列的键值对</td>
</tr>
<tr>
<td>空行</td>
<td>空</td>
</tr>
<tr>
<td>请求正文\请求体(可选)</td>
<td>正文可能有也可能没有，注意和消息报头之间有一个空行，get请求没有</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>释义</th>
<th>释义简写</th>
<th>幂等性</th>
<th>安全性</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>通常只用于<strong>读取数据</strong>，要求服务器将URL定位的文档资源放在响应报文的数据部分，回送给客户端。<br/>例如，&#x2F;index.jsp?id&#x3D;100&amp;op&#x3D;bind。请求参数在“？”后面，长度受限制</td>
<td><strong>获取资源</strong></td>
<td>幂等</td>
<td>安全</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送数据并请求<strong>处理数据返回处理结果</strong><br />默认格式 application&#x2F;x-www-form-urlencoded，表示可传输编码汉字，但是对于英文效率变低</td>
<td><strong>新建资源</strong>（也可以用于更新资源）</td>
<td>非幂等</td>
<td>不安全</td>
</tr>
<tr>
<td>PUT</td>
<td><strong>更新</strong>服务器上<strong>已有的资源</strong></td>
<td><strong>更新资源</strong></td>
<td>幂等</td>
<td>不安全</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的资源</td>
<td><strong>删除资源</strong></td>
<td>幂等</td>
<td>不安全</td>
</tr>
<tr>
<td>HEAD</td>
<td>与GET方法类似，从服务器获取资源信息，和GET方法不同是是，HEAD不含有呈现数据，仅仅是HTTP头信息。HEAD的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获得资源的元信息(或元数据)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>预请求，服务器回传是否支持跨域请求 、资源所支持的请求源、方法、标头等信息</td>
<td>跨域<strong>预检请求</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CONNECT</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>幂等性：是指对<strong>同一个操作</strong>的多次执行所产生的效果是相同的，不会因为<strong>重复提交</strong>而导致数据状态的改变。它确保了在进行数据操作时不会产生意外的副作用，从而保证了系统的稳定性和一致性。</p>
<table>
<thead>
<tr>
<th>消息报头的键值对</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Accept</strong></td>
<td>用于指定客户端希望接收那些类型的信息，如text&#x2F;html image application，application&#x2F;json</td>
</tr>
<tr>
<td><strong>Cookie</strong></td>
<td>用于维护状态，可以做用户认证，服务器检验，是浏览器存储在用户电脑上的文本片段</td>
</tr>
<tr>
<td>Host</td>
<td>请求报头域，指定被请求资源的Internet主机和端口号，通常是从HttpURL中提取出来的</td>
</tr>
<tr>
<td>Connection</td>
<td>表示连接状态，keep-alive是持久连接，即TCP的连接默认是不关闭的，可以被多个请求复用，如果客户端和服务器发现对方有一段时间没有活动，他可以主动关闭连接</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用于指定缓存的指令，no-cache，no-store，max-age&#x3D;3(表示资源在本地缓存了3秒)</td>
</tr>
<tr>
<td>User-Agent</td>
<td>用于标识请求者的一些信息，比如浏览器类型，版本，操作系统，Mozilla是浏览器的规范</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>用于指定可接受的内容编码，即当前浏览器可以进行哪些内容的编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>用于指定可以接受的自然语言，当前浏览器可以解析哪些语言</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h4><p>从三个层面来解答</p>
<p>Http报文层面：GET将<strong>请求信息</strong>放在<strong>URL中</strong>对数据长度有限制，POST放在<strong>报文体中</strong>对数据长度没限制<br>数据库层面：<strong>GET符合幂等性和安全性，POST不符合</strong><br>其他层面：<strong>GET</strong>可以被<strong>CDN缓存</strong>、被存储，而<strong>POST不行</strong></p>
<p>幂等性：对数据库的一次操作和多次操作获得的结果一致<br>安全性：对数据库的操作没有改变数据库中的数据</p>
<h3 id="3响应报文"><a href="#3响应报文" class="headerlink" title="3响应报文"></a>3响应报文</h3><p>HTTP响应报文 &#x3D; 状态行 + 响应头 + 响应正文</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK			(状态行，协议版本、状态码、简要描述)</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sat, 15 Feb 2020 03:57:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8  (响应头中该项必需指明，其他可选)</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Set-Cookie: imooc_isnew=2; expires=Sun, 14-Feb-2021 03:57:21 GMT; Max-Age=31536000; path=/; domain=.imooc.com</span><br><span class="line">Set-Cookie: cvde=5e4618736308b-132; path=/; domain=.imooc.com</span><br><span class="line">Content-Encoding: gzip		(响应头)</span><br><span class="line">Response就是响应正文（可能是HTML页面，可能是Json数据）</span><br><span class="line"></span><br><span class="line">Server：服务器用来处理请求的软件信息，如当前服务器在nginx中间件中</span><br><span class="line">Date：时间信息</span><br><span class="line">Content-Type：浏览器响应正文的数据类型（如application/json、text/html）  (响应正文)</span><br></pre></td></tr></table></figure>



<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_03_23_15.png" alt="image-20230503231554614" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>响应格式</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>状态行</td>
<td>包含HTTP协议版本、状态码和状态描述，以空格分隔</td>
</tr>
<tr>
<td>响应头</td>
<td>即消息报头，包含一系列的键值对</td>
</tr>
<tr>
<td>空行</td>
<td>空</td>
</tr>
<tr>
<td>响应正文</td>
<td>返回内容</td>
</tr>
</tbody></table>
<h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>Body Contents</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>1xx 指示信息</td>
<td></td>
<td>表示请求已接收，继续处理</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2xx 成功</td>
<td></td>
<td>表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td>200 OK</td>
<td>资源</td>
<td>操作成功</td>
</tr>
<tr>
<td>201 Created</td>
<td>资源,元数据</td>
<td>对象创建成功</td>
</tr>
<tr>
<td>202 Accepted</td>
<td>N&#x2F;A(Not applicable 不适用)</td>
<td>请求已经被接收</td>
</tr>
<tr>
<td>203 Non-Authoritative Information</td>
<td></td>
<td>非认证消息</td>
</tr>
<tr>
<td>204 No Content</td>
<td>N&#x2F;A</td>
<td>操作已经执行成功，但是没有返回数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3xx 重定向</td>
<td></td>
<td>-要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>301 Moved Permanently</td>
<td>link</td>
<td>请求永久重定向，资源已被移除</td>
</tr>
<tr>
<td>302 Moved Temporarily</td>
<td></td>
<td>请求临时重定向</td>
</tr>
<tr>
<td>303</td>
<td>link</td>
<td>重定向</td>
</tr>
<tr>
<td>304 Not Modified</td>
<td>N&#x2F;A</td>
<td>资源没有被修改，可以直接使用缓存的文件</td>
</tr>
<tr>
<td>305 Use Proxy</td>
<td></td>
<td>使用代理</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4xx 客户端错误</td>
<td></td>
<td>请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>400 Bad Request</td>
<td>错误提示(消息)</td>
<td>参数列表错误(缺少, 格式不匹配)</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>错误提示(消息)</td>
<td>请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>错误提示(消息)</td>
<td>服务器收到请求，但是拒绝提供服务，服务器通常会在响应正文中给出不提供服务的原因，例如IP被禁、授权过期</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>错误提示(消息)</td>
<td>请求资源不存在，例如输入了错误的URL</td>
</tr>
<tr>
<td>405</td>
<td>错误提示(消息)</td>
<td>不允许的 http 方法</td>
</tr>
<tr>
<td>409</td>
<td>错误提示(消息)</td>
<td>资源冲突，或者资源被锁定</td>
</tr>
<tr>
<td>415</td>
<td>错误提示(消息)</td>
<td>不支持的数据(媒体)类型</td>
</tr>
<tr>
<td>429</td>
<td>错误提示(消息)</td>
<td>请求过多被限制</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5xx 服务器端错误</td>
<td></td>
<td>服务器未能实现合法的请求</td>
</tr>
<tr>
<td>500 Internal Server Error</td>
<td>错误提示(消息)</td>
<td>服务器发生不可预期的错误</td>
</tr>
<tr>
<td>501</td>
<td>错误提示(消息)</td>
<td>接口未实现</td>
</tr>
<tr>
<td>502 Bad Gateway</td>
<td></td>
<td></td>
</tr>
<tr>
<td>503 Server Unavailable</td>
<td></td>
<td>服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
<tr>
<td>504 Gateway Time-out</td>
<td></td>
<td>网关超时</td>
</tr>
<tr>
<td>可以自定义状态码</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="4Cookie和Session的区别"><a href="#4Cookie和Session的区别" class="headerlink" title="4Cookie和Session的区别"></a>4Cookie和Session的区别</h3><p>Cookie数据存放在客户的<strong>浏览器上</strong>，Session数据放在<strong>服务器上</strong><br><strong>Session</strong>相对于Cookie更<strong>安全</strong> (Cookie欺骗)<br>若考虑<strong>减轻服务器负担</strong>，应当使用<strong>Cookie</strong></p>
<p><strong>Cookie</strong> 是服务器发给客户端的特殊信息，以文本的形式存放在客户端。<br>当客户端再次请求服务器时会携带 Cookie。服务器收到后能解析 Cookie 生成与客户端相对应的内容。<br>应用：记住密码、购物车</p>
<p><strong>Session</strong> 是服务器端的机制，能在服务器上保存会话信息。<br>解析客户端请求获得session id，按需保存状态信息。</p>
<p><strong>Session的实现方式</strong><br>使用Cookie来实现，Tomcat 服务器可用 set-cookie: JSESSIONID&#x3D;xxx<br>在Cookie不可用时可以使用HTTP请求头中加入X-Session-ID、URL回写来、隐藏表单域、客户端证书方式实现</p>
<h3 id="5HTTP和HTTPS的区别"><a href="#5HTTP和HTTPS的区别" class="headerlink" title="5HTTP和HTTPS的区别"></a>5HTTP和HTTPS的区别</h3><ul>
<li>HTTPS 服务器需要到<strong>CA (Certificate Authority证书颁发机构)申请证书</strong>(含公钥)，一般免费证书较少，因而需要一定费用</li>
<li>HTTP<strong>明文传输</strong>，HTTPS<strong>密文传输</strong></li>
<li><strong>连接建立方式不同</strong>，并且HTTPS默认使用<strong>443端口</strong>，HTTP使用<strong>80端口</strong>。</li>
<li>HTTPS&#x3D;HTTP+TLS，较HTTP<strong>安全</strong></li>
</ul>
<p>TLS：加密+身份认证+完整性保护(数字签名)</p>
<p>openssh生成自签名证书(没有经过CA机构认证，不安全的)，cacert.pem证书文件、private.key私钥文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private.key 2048  <span class="comment"># 生成私钥文件</span></span><br><span class="line">openssl req -new -key private.key -out cert.csr  <span class="comment"># 根据私钥生成证书签名请求文件CRS文件(Certificate Signing Request)</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> cert.csr -out cacert.pem -signkey private.key  <span class="comment"># 使用私钥对证书申请进行签名从而生成证书文件(pem文件)</span></span><br></pre></td></tr></table></figure>





<h4 id="HTTPS-的安全机制-TLS-的工作原理"><a href="#HTTPS-的安全机制-TLS-的工作原理" class="headerlink" title="HTTPS 的安全机制 TLS 的工作原理"></a>HTTPS 的安全机制 TLS 的工作原理</h4><p><strong>TLS 握手：使用了非对称加密和对称加密结合的方式。使用非对称加密来交换对称密钥，使用对称密钥加密和解密实际的数据</strong></p>
<ol>
<li>客户端向服务器发送HTTPS请求，并将支持的加密算法信息发送给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，并将SSL证书发送给客户端</li>
<li>客户端通过<strong>CA数字签名</strong>验证SSL证书合法性，并生成对称密钥以数据进行加密，使用证书<strong>公钥加密</strong>对称密钥发送给服务器 </li>
<li>服务器使用<strong>私钥解密</strong>得到对称密钥，验证哈希，对称密钥加密响应消息回发客户端</li>
<li>客户端解密响应消息，并对消息进行验真(对源服务器的身份进行身份验证)，之后进行加密交互数据</li>
</ol>
<p>SSL证书包含域名、CA的数字签名、公钥、期限等信息<br>公钥本质上是用于加密和签署数据的长字符串。使用公钥加密的数据只能用私钥解密。<br>对称加密是指加密解密使用同一个密钥。</p>
<h4 id="数字签名原理"><a href="#数字签名原理" class="headerlink" title="数字签名原理"></a>数字签名原理</h4><p>数字签名是一种基于公开密钥加密技术的数字安全机制，用于验证数据的真实性和完整性，以及数据的发送者身份。</p>
<p>数字签名的原理可以概括为以下几个步骤：</p>
<ol>
<li>数据摘要：发送者对需要发送的数据进行<strong>摘要处理</strong> (哈希)，生成一个固定长度的消息摘要（message digest）。</li>
<li>数字签名：发送者使用自己的<strong>私钥</strong>对消息摘要进行<strong>加密，生成数字签名</strong>（digital signature）。</li>
<li>数字证书：发送者将数字签名和原始数据一起发送给接收者，并附带自己的数字证书（digital certificate）。</li>
<li>数字证书验证：接收者使用数字证书中的<strong>公钥</strong>来<strong>解密数字签名，得到消息摘要</strong>。</li>
<li>数据完整性验证：接收者对原始数据进行摘要处理，得到一个新的消息摘要，与解密得到的<strong>消息摘要进行比对</strong>，如果两个消息摘要相同，说明数据在传输过程中没有被篡改。</li>
<li>发送者身份验证：接收者使用数字证书中的发件人信息来验证发送者的身份，以确保数据来自可信的来源。</li>
</ol>
<p>需要注意的是，数字签名的安全性取决于私钥的保密性和公钥的真实性。因此，在实际应用中，数字签名通常需要由可信的第三方机构（如CA机构）来进行认证和管理，以确保数字证书和公钥的真实性和有效性。同时，数字签名也需要定期更新和管理，以应对各种安全威胁和风险。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP 地址具有层次特点，分为网络号、主机号<br>子网掩码的作用就是划分网络号和主机号</p>
<h4 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th>私有IP地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>A类地址</td>
<td>0.0.0.0 到 127.255.255.255，0开头</td>
<td>10.0.0.0&#x2F;8 (10.0.0.0 到 10.255.255.255)<br />本地回环地址127.0.0.1 到 127.255.255.254</td>
<td></td>
</tr>
<tr>
<td>B类地址</td>
<td>128.0.0.0 到 191.255.255.255，10开头</td>
<td>172.16.0.0&#x2F;12 (172.16.0.0 到 172.31.255.255)</td>
<td></td>
</tr>
<tr>
<td>C类地址</td>
<td>192.0.0.0 到 223.255.255.255，110开头</td>
<td>192.168.0.0&#x2F;16 (192.168.0.0 到 192.168.255.255)</td>
<td></td>
</tr>
<tr>
<td>D类地址组播地址</td>
<td>224.0.0.0 到 239.255.255.255，1110开头</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E类地址保留地址</td>
<td>240.0.0.0 到 255.255.255.255，1111开头</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>NAT(Network Address Translation)，私有 IP 地址转换为公共 IP 地址，解决 IPv4 网络地址不足的问题</p>
<h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p>CIDR格式通常为 IP地址&#x2F;子网掩码位数，用于实现IP地址的聚合和划分</p>
<h4 id="URI与URL的区别"><a href="#URI与URL的区别" class="headerlink" title="URI与URL的区别"></a>URI与URL的区别</h4><p>Uniform Resource Identifier 统一资源标识符：更广泛(标识网络资源+本地资源)</p>
<p>Uniform Resource Locator 统一资源定位符：仅网络资源(含协议头)</p>
<h4 id="localhost与127-0-0-1的区别"><a href="#localhost与127-0-0-1的区别" class="headerlink" title="localhost与127.0.0.1的区别"></a>localhost与127.0.0.1的区别</h4><p>localhost 不经网卡传输，不受防火墙和网卡的限制 (更推荐使用)</p>
<p>127.0.0.0&#x2F;8 表示loop back设备</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>Internet Control Message Protocol 用于传递控制消息，是一些网络链路本身的信息<br>ICMP的请求包(TYPE:0x08，CODE:0X00)和回复包(TYPE:0x00，CODE:0X00)，使用包中TYPE字段进行区分<br><strong>ICMP是IP的一部分，可以进行retry重试</strong></p>
<p>应用：<br>ping 主要获得到目标主机链路的时延信息<br>时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p>
<p>区别：<br>ARP是在局域网内广播的，ICMP不受网络范围限制，也可以判断外网链路情况</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层将网络层的数据包封装成数据帧再在网络中进行传输。网卡接收数据帧，根据帧中目的MAC地址判断是否丢弃，所以在发送数据包之前必须知道目的主机的MAC地址</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>Address Resolution Protocol 用于根据IP地址查MAC地址</p>
<p>过程：先查ARP缓冲表，查不到则在局域网中发送ARP广播</p>
<p>应用：<br>Python中 scapy 模块：就实现ARP协议，可以知道可以通达的目标主机的MAC地址，可以知道网络有哪些存活的主机<br>使用户能够嗅探、剖析、伪造、发送网络数据包，可以构建扫描、探测、攻击网络的工具</p>
<h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket 套接字"></a>Socket 套接字</h2><p><strong>Socket 是对 TCP&#x2F;IP 协议的抽象</strong>，是操作系统对外开放的<strong>接口</strong>，可以视作一个<strong>唯一标识</strong>即 Socket &#x3D; IP + 协议 + 协议端口号。</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_06_14_40.png" alt="image-20230506144053203" style="zoom:75%;" />

<p>Socket通信流程</p>
<img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_06_14_41.png" alt="image-20230506144116472" style="zoom:90%;" />

<h3 id="Java-Socket-编程题"><a href="#Java-Socket-编程题" class="headerlink" title="Java Socket 编程题"></a>Java Socket 编程题</h3><p>编写一个网络应用程序，有客户端与服务器端，<strong>客户端</strong>向服务器<strong>发送一个字符串</strong>，<strong>服务器</strong>收到该字符串后将其打印到命令行上，然后向客户端<strong>返回该字符串的长度</strong>，最后，客户端输出服务器端返回的该字符串的长度，分别用<strong>TCP</strong>和<strong>UDP</strong>两种方式去实现。</p>
<h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建socket,并将socket绑定到65000端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">65000</span>);</span><br><span class="line">        <span class="comment">//死循环，使得socket一直等待并处理客户端发送过来的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//监听65000端口，直到客户端返回连接信息后才返回</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="comment">//获取客户端的请求信息后，执行相关业务逻辑</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LengthCalculator</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LengthCalculator</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//以socket为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LengthCalculator</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取socket的输出流</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="comment">//获取socket的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            ch = is.read(buff);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过来的字符串参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buff, <span class="number">0</span>, ch);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            <span class="comment">//往输出流里写入获得的字符串的长度，回发给客户端</span></span><br><span class="line">            os.write(String.valueOf(content.length()).getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要忘记关闭输入输出流以及socket</span></span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建socket，并指定连接的是本机的端口号为65000的服务器socket</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">65000</span>);</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中</span></span><br><span class="line">        os.write(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello world&quot;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度</span></span><br><span class="line">        ch = is.read(buff);</span><br><span class="line">        <span class="comment">//将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buff, <span class="number">0</span>, ch);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//不要忘记关闭输入输出流以及socket</span></span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 服务端接受客户端发送的数据报</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">65001</span>); <span class="comment">//监听的端口号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以像TCPServer中一样创建线程处理，但是这里为了简便没创建线程</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>]; <span class="comment">//存储从客户端接受到的内容</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buff, buff.length);</span><br><span class="line">        <span class="comment">//接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData(); <span class="comment">//从DatagramPacket对象中获取到真正存储的数据</span></span><br><span class="line">        <span class="comment">//将数据从二进制转换成字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//将要发送给客户端的数据转换成二进制</span></span><br><span class="line">        <span class="type">byte</span>[] sendedContent = String.valueOf(content.length()).getBytes();</span><br><span class="line">        <span class="comment">// 服务端给客户端发送数据报</span></span><br><span class="line">        <span class="comment">//从DatagramPacket对象中获取到数据的来源地址与端口号</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packetToClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(sendedContent,</span><br><span class="line">                sendedContent.length, packet.getAddress(), packet.getPort());</span><br><span class="line">        socket.send(packetToClient); <span class="comment">//发送数据给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 客户端发数据报给服务端</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 要发送给服务端的数据</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="string">&quot;Hello World&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 将IP地址封装成InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, address,</span><br><span class="line">                <span class="number">65001</span>);</span><br><span class="line">        <span class="comment">// 发送数据给服务端</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端接受服务端发送过来的数据报</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">// 创建DatagramPacket对象用来存储服务端发送过来的数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">receivedPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length);</span><br><span class="line">        <span class="comment">// 将接受到的数据存储到DatagramPacket对象中</span></span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        <span class="comment">// 将服务器端发送过来的数据取出来并打印到控制台</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(receivedPacket.getData(), <span class="number">0</span>,</span><br><span class="line">                receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>Internet 因特网</p>
<p>Ethernet 以太网是一种局域网中传输数据的技术，介质访问控制方法使用CSMA&#x2F;CD(载波侦听多路访问&#x2F;碰撞检测)协议(避免多个节点同时发送数据导致的碰撞，从而保证数据的可靠传输)</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>CAT：5类线100Mbps、5e超五类1000Mbps、6类线1Gbps</p>
<p>568B：白橙橙白绿蓝</p>
<p> awg 直径：24粗、26细，24粗好</p>
<h3 id="路由器与交换机的区别"><a href="#路由器与交换机的区别" class="headerlink" title="路由器与交换机的区别"></a>路由器与交换机的区别</h3><table>
<thead>
<tr>
<th>二层交换机</th>
<th>路由器</th>
</tr>
</thead>
<tbody><tr>
<td>通过传输媒介和接口连接设备</td>
<td>通过路由表来连接设备</td>
</tr>
<tr>
<td>设备要在同一个子网内(三层交换机可以跨网段，三层指网络层具有路由功能)</td>
<td>设备可以不再同一个子网内</td>
</tr>
<tr>
<td>利用网线连接不同网络设备，起到设备连接功能，决定网线使用哪个接口转发(数据交换)</td>
<td>路由转发(跨网段通信)</td>
</tr>
</tbody></table>
<h1 id="我的"><a href="#我的" class="headerlink" title="我的"></a>我的</h1><p>路由器固件：H大的padavan老毛子(192.168.123.1)+breed控制台、openwrt、<a target="_blank" rel="noopener" href="https://github.com/istoreos/istoreos">istoreos</a>(推荐)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.haruharu.top">Nemesis</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.haruharu.top/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Dev/Network/Network/">https://blog.haruharu.top/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Dev/Network/Network/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.haruharu.top" target="_blank">Nemesis</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_05_01_15_19.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/articles/Linux/Dev/Linux/Linux/" title="Linux"><img class="cover" src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_04_30_21_35.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux</div></div></a></div><div class="next-post pull-right"><a href="/articles/%E6%95%B0%E6%8D%AE%E5%BA%93/Dev/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL8/" title="关系型数据库"><img class="cover" src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting1/img/2023_03_28_14_30.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关系型数据库</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nemesis</div><div class="author-info__description">浙江外国语学院大四老人 <br/> Talk is cheap. Show me the code.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/chenxiangcheng1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxiangcheng1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:chenxiangcheng1@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">有空B站直播写代码 ( •̀ ω •́ )✧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%BB%E8%A6%81%E8%80%83%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">计算机网络主要考点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-%E5%92%8C-TCP-IP"><span class="toc-number">1.1.</span> <span class="toc-text">OSI 和 TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">1.2.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">三次握手的过程 (基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">为什么要第三次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84-SYN-Cookie-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">TCP的 SYN Cookie 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">TCP 保活机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.4.</span> <span class="toc-text">四次挥手的过程 (基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">为什么要四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">为什么连接三次握手，关闭却是四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E6%9C%BA1%E8%A6%81%E6%9C%89TIME-WAIT%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">为什么主机1要有TIME_WAIT状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">服务器出现大量 CLOSE_WAIT 状态的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.6.</span> <span class="toc-text">TCP流量控制 滑动窗口机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.7.</span> <span class="toc-text">TCP拥塞控制 拥塞窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">1.3.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3"><span class="toc-number">1.3.1.</span> <span class="toc-text">HTTP&#x2F;3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">1请求与响应过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">2请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">GET请求和POST请求的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">1.3.4.</span> <span class="toc-text">3响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">响应状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.5.</span> <span class="toc-text">4Cookie和Session的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.6.</span> <span class="toc-text">5HTTP和HTTPS的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS-%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6-TLS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">HTTPS 的安全机制 TLS 的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">数字签名原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.4.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">层次划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">NAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CIDR"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">CIDR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URI%E4%B8%8EURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">URI与URL的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localhost%E4%B8%8E127-0-0-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">localhost与127.0.0.1的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP"><span class="toc-number">1.4.2.</span> <span class="toc-text">ICMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.5.</span> <span class="toc-text">数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP"><span class="toc-number">1.5.1.</span> <span class="toc-text">ARP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.6.</span> <span class="toc-text">Socket 套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Socket-%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">Java Socket 编程题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-1"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">UDP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">1.7.</span> <span class="toc-text">局域网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF"><span class="toc-number">1.8.1.</span> <span class="toc-text">双绞线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.2.</span> <span class="toc-text">路由器与交换机的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%88%91%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">我的</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/articles/uncategorized/Dev/%E6%96%B0%E6%96%87%E7%AB%A0/" title="新文章"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="新文章"/></a><div class="content"><a class="title" href="/articles/uncategorized/Dev/%E6%96%B0%E6%96%87%E7%AB%A0/" title="新文章">新文章</a><time datetime="2024-06-01T15:11:34.000Z" title="发表于 2024-06-01 23:11:34">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/small-language/Dev/language/small-language/YAML1.2/" title="YAML"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YAML"/></a><div class="content"><a class="title" href="/articles/small-language/Dev/language/small-language/YAML1.2/" title="YAML">YAML</a><time datetime="2024-04-19T16:00:00.000Z" title="发表于 2024-04-20 00:00:00">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Dev/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Nginx/" title="Nginx"><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2023_09_25_08_26_56.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx"/></a><div class="content"><a class="title" href="/articles/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Dev/%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6/Web%E4%B8%AD%E9%97%B4%E4%BB%B6/Nginx/" title="Nginx">Nginx</a><time datetime="2024-03-17T16:00:00.000Z" title="发表于 2024-03-18 00:00:00">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/Dev/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="桥接模式"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="桥接模式"/></a><div class="content"><a class="title" href="/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/Dev/design-patterns/%E7%BB%93%E6%9E%84%E5%9E%8B/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" title="桥接模式">桥接模式</a><time datetime="2024-03-12T16:00:00.000Z" title="发表于 2024-03-13 00:00:00">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/Dev/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式"><img src="https://cdn.jsdelivr.net/gh/ChenXiangcheng1/image-hosting2/img/2024_0308_133937.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="抽象工厂模式"/></a><div class="content"><a class="title" href="/articles/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/Dev/design-patterns/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" title="抽象工厂模式">抽象工厂模式</a><time datetime="2024-03-07T16:00:00.000Z" title="发表于 2024-03-08 00:00:00">2024-03-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Nemesis</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>